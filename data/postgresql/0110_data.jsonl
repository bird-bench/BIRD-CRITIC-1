{"instance_id": "270_1", "selected_database": "financial", "query": "In the financial database, we have a table named 'order' that records details about orders given to clients. Each order is associated with an order_id and has attributes such as account_id, bank_to, account_to, and amount. We need to find all accounts that have placed at least two orders such that the difference between the highest and lowest amount for those orders exceeds 12000. This query aims to find such accounts, but the initial attempt produced incorrect results.", "error_sql": ["SELECT account_id, MAX(payments) AS max_payment, MIN(payments) AS min_payment FROM loan GROUP BY account_id HAVING COUNT(account_id) > 1 AND (MAX(payments) - MIN(payments)) > 2;"], "sol_sql": ["SELECT DISTINCT account_id FROM \"order\" GROUP BY account_id HAVING COUNT(order_id) > 1 AND (MAX(amount) - MIN(amount)) > 12000;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "271_2", "selected_database": "codebase_community", "query": "I have a table named 'comments' in the 'codebase_community' database with a column 'CreationDate' of type 'datetime'. I want to extract only the 'hh:mm:ss' part from this column. My desired result should look like this:\n\n\n0:00:00\n10:00:00\n04:00:00\n\n\nHowever, when I tried to use the following SQL query, it didn't give me the expected result:\n\nsql\nSELECT CreationDate::time FROM comments;\n\n\nThis query returns the time part but includes leading zeros, which I don't want. How can I modify my query to achieve the desired result?", "error_sql": ["SELECT CreationDate::time FROM comments;"], "sol_sql": ["SELECT to_char(CreationDate, 'FMHH:MI:SS') FROM comments;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "333_1", "selected_database": "financial", "query": "I'm exploring triggers and want to create one that fires after an Update event on a `status` column in the `loan` table. The column contains text values representing loan statuses, so the user may update the loan status. I want the trigger function to calculate the number of loans with a specific status 'A' for a certain account. Then update `total_loan_count` in a `loan_summary` table. Here is my trigger (which is not working and I want to figure out why):", "error_sql": ["CREATE OR REPLACE FUNCTION total_loans()\n    RETURNS TRIGGER \n    AS $$ \n    BEGIN \n        UPDATE loan_summary \n        SET total_loan_count = (SELECT COUNT(CASE WHEN status = 'A' THEN 1 END) FROM loan WHERE loan_summary.account_id = loan.account_id) WHERE account_id = NEW.account_id; RETURN NEW; \n    END; \n    $$ LANGUAGE plpgsql;", "\n    CREATE TRIGGER tr_total_loans AFTER UPDATE OF status FOR EACH ROW EXECUTE PROCEDURE total_loans();\n    "], "sol_sql": ["\n    CREATE OR REPLACE FUNCTION total_loans()\n    RETURNS TRIGGER\n    AS $$\n    BEGIN \n        UPDATE loan_summary\n        SET total_loan_count = ( \n            SELECT COUNT(*) \n            FROM loan \n            WHERE loan.account_id = loan_summary.account_id\n              AND loan.status = 'A') \n        WHERE loan_summary.account_id = NEW.account_id; \n        RETURN NEW;\n    END;\n    $$ LANGUAGE plpgsql;\n    ", "\n    CREATE TRIGGER tr_total_loans AFTER UPDATE OF status ON loan FOR EACH ROW EXECUTE PROCEDURE total_loans();\n    "], "preprocess_sql": ["DROP TABLE IF EXISTS loan_summary;", "CREATE TABLE loan_summary (account_id INT PRIMARY KEY, total_loan_count INT);", "INSERT INTO loan_summary (account_id, total_loan_count) SELECT l.account_id, COUNT(*) FROM loan l WHERE l.status = 'A' GROUP BY l.account_id;"], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res, _, _ = execute_queries([\"SELECT account_id, total_loan_count FROM loan_summary ORDER BY account_id LIMIT 1;\"], db_name,conn)\n    account_id, loan_count = res[0][0], res[0][1]\n    res, _, _ = execute_queries([f\"SELECT loan_id, account_id FROM loan WHERE account_id = {account_id} AND status = 'A' LIMIT 1;\"], db_name,conn)\n    loan_id = res[0][0]\n    check_sql = [f\"UPDATE loan SET status = 'B' WHERE loan_id = {loan_id};\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([f\"SELECT total_loan_count FROM loan_summary WHERE account_id = {account_id};\"], db_name,conn)\n    new_count = res[0][0]\n    assert new_count == (loan_count - 1), f\"The trigger does not work.\"\n"]}
{"instance_id": "335_2", "selected_database": "european_football_2", "query": "In the context of managing team attributes in the European Football database, a user attempted to add a new value 'Very Fast' to an existing ENUM type for 'buildupplayspeedclass' in the 'team_attributes' table. The user tried an approach: renaming the existing ENUM and creating a new one with the additional value, and switch the data type in place. The approach resulted in locks that caused application downtime, especially considering the table's size in the millions of rows. The user is seeking a solution that avoids such downtime, possibly by considering a different approach than using ENUMs.", "error_sql": ["ALTER TYPE buildupplayspeedclass RENAME TO buildupplayspeedclass_old;", "CREATE TYPE buildupplayspeedclass AS ENUM ('Slow', 'Balanced', 'Fast', 'Very Fast');", "ALTER TABLE Team_Attributes ALTER COLUMN buildupplayspeedclass SET DATA TYPE buildupplayspeedclass USING buildupplayspeedclass::text::buildupplayspeedclass;", "DROP TYPE buildupplayspeedclass;"], "sol_sql": ["ALTER TYPE buildupplayspeedclass_enum ADD VALUE 'Very Fast';"], "preprocess_sql": ["CREATE TYPE buildupplayspeedclass_enum AS ENUM ('Balanced', 'Fast', 'Slow');", "\n    ALTER TABLE team_attributes\n    ALTER COLUMN buildupplayspeedclass\n    TYPE buildupplayspeedclass_enum\n    USING buildupplayspeedclass::buildupplayspeedclass_enum;"], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\"SELECT id FROM team_attributes LIMIT 1;\"]\n    res, _, _ = execute_queries(queries,  db_name, conn)\n    team_id = res[0][0]\n    queries = [f\"UPDATE team_attributes SET buildupplayspeedclass = 'Very Fast' WHERE id = {team_id};\"]\n    _, exec_err, time_err = execute_queries(queries, db_name, conn)\n    assert exec_err == False\n    \n    queries = [f\"UPDATE team_attributes SET buildupplayspeedclass = 'TEST' WHERE id = {team_id};\"]\n    res, exec_err, _ = execute_queries(queries, db_name, conn)\n    assert exec_err == True\n"]}
{"instance_id": "336_2", "selected_database": "student_club", "query": "In the student_club database, I created a unique index on the `event` table using the following queries 'CREATE UNIQUE INDEX unique_name ON event(event_name, event_date) where event_name is not null; CREATE UNIQUE INDEX unique_location ON event(location, event_date) where location is not null;'. However, when I attempt to insert a new record using an UPSERT operation using the query 'insert into event (event_id, event_name, location, event_date) values('test1', 'test_name', 'test_location', 'test_date')on conflict (event_name, location, event_date) do update set event_id = 'test1', event_name = 'test_name', location = 'test_location', event_date = 'test_date'', I encounter an error stating that there is no unique or exclusion constraint matching the ON CONFLICT specification.", "error_sql": ["CREATE UNIQUE INDEX unique_name ON event(event_name, event_date) where event_name is not null;CREATE UNIQUE INDEX unique_location ON event(location, event_date) where location is not null;"], "sol_sql": ["CREATE UNIQUE INDEX unique_name_location ON event(event_name, location, event_date) WHERE coalesce(event_name, location) is not null;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    check_queries = [\n        \"\"\"\n        INSERT INTO event (event_id, event_name, location, event_date)\n        VALUES ('test1', 'test_name', 'test_location', 'test_date');\n        \"\"\"\n    ]\n    execute_queries(check_queries, db_name, conn)\n    \n    check_queries = [\n        \"\"\"\n        insert into event (event_id, event_name, location, event_date)\n\n        values('test2', 'test_name', 'test_location', 'test_date')\n        on conflict (event_name, location, event_date)        \n        where coalesce(event_name, location) is not null \n        do update set\n            event_id = excluded.event_id,\n            event_name = excluded.event_name,\n            location = excluded.location,\n            event_date = excluded.event_date \"\"\"\n    ]\n    res, exec_err, _ = execute_queries(check_queries, db_name, conn)\n    assert exec_err == False\n    queries = [\"SELECT event_id, event_name, location, event_date FROM event WHERE event_name = 'test_name';\"]\n    res, _, _ = execute_queries(queries, db_name, conn)\n    assert len(res) == 1\n    assert res[0][0] == 'test2'\n"]}
{"instance_id": "337_2", "selected_database": "card_games", "query": "I want to query language from the 'set_translations' table and also find if the language exists in the 'foreign_data' table. I have the following query but it doesn't seem to work. Any suggestions what I did wrong?", "error_sql": ["SELECT set_translations.language\n              CASE WHEN set_translations.language IN (SELECT foreign_data.language in foreign_data)\n              THEN 'common'\n              ELSE 'not common'\n              END\n        FROM set_translations\n    "], "sol_sql": ["\n    select set_translations.language, \n    CASE\n        WHEN EXISTS (select *\n                    from foreign_data\n                    where foreign_data.language = set_translations.language)\n        THEN 'common'\n        ELSE 'not common'\n    END\n    from\n    set_translations\n   "], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "338_1", "selected_database": "debit_card_specializing", "query": "In the following SQL, how could I make the `RETURNING` clause join to something else and return the joined row(s)? Here it only returns the row from `transactions_1k` that was updated, but I'd like it to return that row joined to something in another table, e.g. joined to `customers` tables and get both `transactions_1k.transactionid` and `customers.Segment` columns.", "error_sql": ["\n    UPDATE transactions_1k \n    SET Amount = 100 \n    FROM ( SELECT TransactionID FROM transactions_1k WHERE Amount = 50 ORDER BY Date LIMIT 100 FOR UPDATE ) sub \n    WHERE transactions_1k.TransactionID = sub.TransactionID RETURNING *;\n    "], "sol_sql": ["\n    UPDATE transactions_1k \n    SET Amount = 100 \n    FROM ( SELECT customerid, transactionid FROM transactions_1k WHERE Amount = 50 ORDER BY Date LIMIT 100 FOR UPDATE ) sub \n    JOIN customers c ON c.customerid = sub.customerid WHERE transactions_1k.transactionid = sub.transactionid RETURNING transactions_1k.transactionid, c.Segment;\n   "], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\nimport datetime\n\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) == 2\n    assert pred_query_result == [(947, 'SME'), (988, 'KAM')]"]}
{"instance_id": "235_3", "selected_database": "codebase_community", "query": "I have a query that calculates the number of referrals each user has made. However, I want to count a referral only if the referred user has activated their premium account. How can I achieve this?", "error_sql": ["SELECT users.Id, COUNT(posts.Id) as answered FROM users LEFT JOIN posts ON users.Id = posts.OwnerUserId GROUP BY users.Id ORDER BY answered DESC;"], "sol_sql": ["SELECT users.Id, COUNT(posts.Id) FILTER (WHERE AnswerCount > 0) as answered FROM users LEFT JOIN posts ON users.Id = posts.OwnerUserId GROUP BY users.Id ORDER BY answered DESC;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "231_2", "selected_database": "card_games", "query": "In the card_games database, we have a table named 'sets' which stores information about different card sets. Each set has a unique code and a name. We want to upsert data into this table where we insert a new set if it doesn't exist or update the existing set if it does. Specifically, we want to insert or update sets with the following data: ('10E', 'Tenth Edition') and ('2ED', 'Unlimited Edition'). If the set already exists, we want to update the name to the new value provided. However, the current UPSERT query does not return the IDs of the inserted or updated rows when there are no conflicts, and it returns nothing when there are conflicts. We need a query that returns the IDs of the inserted or updated rows regardless of whether there were conflicts or not.", "error_sql": ["INSERT INTO sets (code, name) VALUES ('10E', 'Tenth Edition'), ('2ED', 'Unlimited Edition') ON CONFLICT(code) DO NOTHING RETURNING id;"], "sol_sql": ["INSERT INTO sets (code, name) VALUES ('10E', 'Tenth Edition'), ('2ED', 'Unlimited Edition') ON CONFLICT(code) DO UPDATE SET name = EXCLUDED.name RETURNING id;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT name FROM sets WHERE code = '10E';\"], db_name,conn)[0] \n    assert test_pred_query_result_1[0][0] == 'Tenth Edition', f'Expected name to match, but found {test_pred_query_result_1[0][0]}'\n    test_pred_query_result_1 = execute_queries([\"SELECT name FROM sets WHERE code = '2ED';\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == 'Unlimited Edition', f'Expected name to match, but found {test_pred_query_result_1[0][0]}'", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows' \n    assert pred_query_result[0][0] == 1, f'Expected duplicate id is 1, but found {pred_query_result[0][0]}'\n    assert pred_query_result[1][0] == 2, f'Expected duplicate id is 2, but found {pred_query_result[1][0]}'\n"]}
{"instance_id": "233_3", "selected_database": "codebase_community", "query": "I want to drop the 'users' table from the 'codebase_community' database. However, when I attempt to drop the table using the SQL command `DROP TABLE IF EXISTS users;`, I encounter an error message stating: 'cannot drop table users because other objects depend on it'. This issue arises because the 'users' table is referenced by foreign keys in other tables such as 'badges', 'comments', 'postHistory', 'posts', and 'votes'. I am seeking a solution to drop the 'users' table without having to remove all dependent tables or data.", "error_sql": ["DROP TABLE IF EXISTS users;"], "sol_sql": ["DROP TABLE IF EXISTS users CASCADE;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_users_table = execute_queries([\"SELECT COUNT(*) FROM information_schema.tables WHERE table_name = 'users';\"], 'codebase_community',conn)[0]\n    assert test_users_table[0][0] == 0, 'Users table should be dropped.'", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_posts_lasteditoruserid_fkey = execute_queries([\"SELECT COUNT(*) FROM information_schema.table_constraints WHERE table_name = 'posts' AND constraint_name = 'posts_ibfk_1';\"], 'codebase_community',conn)[0] \n    assert test_posts_lasteditoruserid_fkey[0][0] == 0, 'Foreign key posts_lasteditoruserid_fkey should be dropped.'\n    test_posts_owneruserid_fkey = execute_queries([\"SELECT COUNT(*) FROM information_schema.table_constraints WHERE table_name = 'posts' AND constraint_name = 'posts_ibfk_2';\"], 'codebase_community',conn)[0] \n    assert test_posts_owneruserid_fkey[0][0] == 0, 'Foreign key posts_owneruserid_fkey should be dropped.'\n"]}
{"instance_id": "234_3", "selected_database": "student_club", "query": "We have an attendance table where each row is identified by (link_to_member, link_to_event) as the primary key. Suppose the member with ID 'rec280Sk7o31iG0Tx' (e.g., John Smith) is currently attending an event 'recggMW2eyCYceNcy' (an old event). We want to update that member's attendance record so that instead they will attend 'recI43CzsZ0Q625ma' (the new event). However, if the member already has a record for the new event, then the UPDATE would violate the primary key constraint. In that case, we want to skip the update entirely. Therefore, we must add a NOT EXISTS clause to check if the new (link_to_member, link_to_event) pair is already in the table, and only proceed with the update if it's safe to do so.", "error_sql": ["UPDATE attendance SET link_to_event = 'recI43CzsZ0Q625ma' WHERE link_to_member = 'rec280Sk7o31iG0Tx' AND link_to_event = 'recggMW2eyCYceNcy';"], "sol_sql": ["UPDATE attendance SET link_to_event = 'recI43CzsZ0Q625ma' WHERE link_to_member = 'rec280Sk7o31iG0Tx' AND link_to_event = 'recggMW2eyCYceNcy' AND NOT EXISTS (SELECT 1 FROM attendance WHERE link_to_member = 'rec280Sk7o31iG0Tx' AND link_to_event = 'recI43CzsZ0Q625ma');"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT * FROM attendance WHERE link_to_member = 'rec280Sk7o31iG0Tx' AND link_to_event = \\'recI43CzsZ0Q625ma\\';\"], 'student_club',conn)[0] \n    test_pred_query_result_2 = execute_queries([\"SELECT * FROM attendance WHERE link_to_member = 'rec280Sk7o31iG0Tx' AND link_to_event = 'recggMW2eyCYceNcy';\"], 'student_club',conn)[0] \n    assert len(test_pred_query_result_2) == 1, 'The update does not happen.'", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_3 = execute_queries([\"SELECT * FROM attendance WHERE link_to_event = 'recI43CzsZ0Q625ma';\"], 'student_club',conn)[0] \n    assert len(test_pred_query_result_3) == 27, f'There should be 27 records with link_to_event = recI43CzsZ0Q625ma but not {test_pred_query_result_3}'\n    test_pred_query_result_4 = execute_queries([\"SELECT COUNT(*) FROM attendance WHERE link_to_member = 'rec280Sk7o31iG0Tx' AND link_to_event = 'recI43CzsZ0Q625ma';\"], 'student_club',conn)[0] \n    assert test_pred_query_result_4[0][0] == 1, 'There should be exactly one record with the updated link_to_event.'\n    test_pred_query_result_5 = execute_queries(['SELECT COUNT(*) FROM attendance;'], 'student_club',conn)[0] \n    assert test_pred_query_result_5[0][0] == 326, 'The total number of records in the attendance table should remain unchanged after the update.'\n"]}
{"instance_id": "236_2", "selected_database": "student_club", "query": "In database student_club, there is a set of users. A student can have multiple users, but ref1 and ref2 might be alike and can therefore link users together. ref1 and ref2 does not overlap, one value in ref1 does not exist in ref2.  A user can own multiple assets. I want to \"merge\" users that has one or more refs alike and then count how many assets they own together. There could be missing entries in the user table, in that case I just want to propagate the owner into ref2 and set the asset_count and asset_ids.", "error_sql": ["SELECT  ARRAY_AGG(DISTINCT u.id) AS ids, ARRAY_AGG(DISTINCT u.username) AS usernames, ARRAY_AGG(DISTINCT u.ref1) AS refs1, ARRAY_AGG(DISTINCT u.ref2) AS refs2,  COUNT(DISTINCT a.id) AS asset_count FROM assets a JOIN users u ON a.owner = u.ref1 OR a.owner = u.ref2 GROUP BY a.owner ORDER BY MIN(a.id);"], "sol_sql": ["WITH RECURSIVE nodes AS (SELECT u.id, r.ref FROM users u CROSS JOIN LATERAL (VALUES (u.ref1), (u.ref2)) r(ref)), edges AS (SELECT DISTINCT n1.id AS id1, n2.id AS id2 FROM nodes n1 INNER JOIN nodes n2 ON n1.ref = n2.ref), rcte AS (SELECT id1, id2, ARRAY[id1] AS visited FROM edges WHERE id1 = id2 UNION ALL SELECT r.id1, e.id2, r.visited || e.id2 FROM rcte r INNER JOIN edges e ON e.id1 = r.id2 WHERE e.id2 <> ALL(r.visited)), groups AS (SELECT id1 AS id, ARRAY_AGG(DISTINCT id2 ORDER BY id2) AS ids FROM rcte GROUP BY id1) SELECT g.ids, array_agg(DISTINCT u.username) AS usernames, array_agg(DISTINCT u.ref1) AS refs1, CASE WHEN g.ids IS NULL THEN array_agg(DISTINCT a.owner) ELSE array_agg(DISTINCT u.ref2) END AS refs2, array_agg(DISTINCT a.id) AS asset_ids, COUNT(DISTINCT a.id) AS asset_count FROM assets a LEFT JOIN users u ON a.owner IN (u.ref1, u.ref2) LEFT JOIN groups g ON g.id = u.id GROUP BY g.ids;"], "preprocess_sql": ["CREATE TABLE assets (id serial, name text, owner text, PRIMARY KEY(id));", "CREATE TABLE users (id serial, username text, ref1 text, ref2 text, PRIMARY KEY(id));", "INSERT INTO assets (name, owner) VALUES ('#1', 'a'), ('#2', 'b'), ('#3', 'c'), ('#4', 'a'), ('#5', 'c'), ('#6', 'd'), ('#7', 'e'), ('#8', 'd'), ('#9', 'a'), ('#10', 'a'), ('#11', 'z');", "INSERT INTO users (username, ref1, ref2) VALUES ('bobo', 'a', 'd'), ('toto', 'b', 'e'), ('momo', 'c', 'd'), ('lolo', 'a', 'f'), ('popo', 'c', 'f');"], "clean_up_sql": ["drop table if exists users;", "drop table if exists assets;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'student_club', conn)\n    sol_sqls_result = execute_queries(sol_sqls, 'student_club', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "239_3", "selected_database": "student_club", "query": "I am trying to compare the number of attendees for each event between two different tables: 'attendance' and 'budget'. I want to find events where the number of attendees in the 'attendance' table does not match the number of attendees recorded in the 'budget' table. My query follows this structure:", "error_sql": ["WITH CTE AS ( SELECT link_to_event, COUNT(link_to_member) AS count FROM attendance GROUP BY link_to_event ) SELECT CTE.link_to_event, CTE.count AS newCount, budget.count AS oldCount FROM budget JOIN CTE ON budget.link_to_event = CTE.link_to_event WHERE budget.count != CTE.count;"], "sol_sql": ["WITH CTE AS ( SELECT link_to_event, COUNT(link_to_member) AS count FROM attendance GROUP BY link_to_event ), CTE2 AS ( SELECT link_to_event, COUNT(budget_id) AS count FROM budget GROUP BY link_to_event) SELECT CTE.link_to_event, CTE.count AS newCount, CTE2.count AS oldCount FROM CTE2 JOIN CTE ON CTE2.link_to_event = CTE.link_to_event WHERE CTE2.count != CTE.count;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "241_3", "selected_database": "student_club", "query": "In the student_club database, we have a scenario where a member can attend multiple events, and an event can have multiple attendees. However, a member can only attend an event once. If a member attempts to attend the same event again, the system should update the attendance record with new information, such as status attend. The current approach is to use an INSERT statement, but it fails when the member already has an attendance record for the event. We need to implement an insert statement that updates the existing record if a conflict occurs based on the combination of member_id and event_id.", "error_sql": "INSERT INTO attendance VALUES ('recEVTik3MlqbvLFi', 'rec280Sk7o31iG0Tx', 1)", "sol_sql": "INSERT INTO attendance (link_to_event, link_to_member, attend) VALUES ('recEVTik3MlqbvLFi', 'rec280Sk7o31iG0Tx', 1) ON CONFLICT (link_to_event, link_to_member) DO UPDATE SET attend = 1;", "preprocess_sql": ["ALTER TABLE attendance ADD COLUMN attend INTEGER DEFAULT 0;"], "clean_up_sql": ["ALTER TABLE attendance DROP COLUMN attend;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    test_query_result_1 = execute_queries([\"SELECT attend FROM attendance WHERE link_to_event = 'recEVTik3MlqbvLFi' AND link_to_member = 'rec280Sk7o31iG0Tx'\"], 'student_club', conn)[0]\n    assert len(test_query_result_1) == 1, f'Expected 1 row, but found {len(test_query_result_1)} rows.'\n    assert test_query_result_1[0][0] == 1, f'Expected attend is updated to 1, but found it is {test_query_result_1[0][0]}'\n    test_query_result_2 = execute_queries([\"SELECT * FROM attendance WHERE attend = 1\"], 'student_club', conn)[0]\n    assert test_query_result_2[0][0] == 'recEVTik3MlqbvLFi', f'Expected recEVTik3MlqbvLFi, but found {test_query_result_2[0][0]}'\n    assert test_query_result_2[0][1] == 'rec280Sk7o31iG0Tx', f'Expected rec280Sk7o31iG0Tx, but found {test_query_result_2[0][1]}'"]}
{"instance_id": "339_1", "selected_database": "financial", "query": "I am trying to create a function that performs some calculations using temporary tables within the function `calculate_loan_status`. However, I am encountering syntax errors when attempting to declare and use these temporary tables. Below is the problematic SQL code I have tried, followed by the error messages I received. I want to understand the correct syntax to achieve this.", "error_sql": ["\n    CREATE FUNCTION calculate_loan_status() \n    RETURNS SETOF loan_last\n    AS $$\n    DECLARE temp_table TABLE (loan_id int, status text); \n    BEGIN INSERT INTO temp_table \n    SELECT loan_id, status FROM loan_first WHERE status = 'A'; \n    INSERT INTO loan_last SELECT loan_id, status FROM temp_table; \n    RETURN; \n    END; \n    $$ LANGUAGE plpgsql;\n    "], "sol_sql": ["\n    CREATE FUNCTION calculate_loan_status() \n    RETURNS SETOF loan_last\n    AS $$\n    BEGIN\n    CREATE TEMP TABLE IF NOT EXISTS temp_table AS\n    SELECT loan_id, status\n    FROM loan_first;\n    INSERT INTO loan_last SELECT loan_id, status FROM temp_table; \n    DROP TABLE temp_table;\n    END;\n    $$ LANGUAGE plpgsql;\n    "], "preprocess_sql": ["\n    DROP TABLE IF EXISTS loan_first;\n    CREATE TABLE loan_first AS\n    SELECT loan_id, status\n    FROM loan\n    ORDER BY loan_id\n    LIMIT 100;\n    ", "\n    DROP TABLE  IF EXISTS loan_last;\n    CREATE TABLE loan_last AS\n    SELECT loan_id, status\n    FROM loan\n    ORDER BY loan_id DESC\n    LIMIT 100;\n    "], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries([\"DROP FUNCTION IF EXISTS calculate_loan_status;\"], db_name, conn)\n    res, exec_err, _ = execute_queries(pred_sqls, db_name, conn)\n    assert exec_err == False\n    "]}
{"instance_id": "340_1", "selected_database": "financial", "query": "In the financial database, there is a need to convert the data from a `BIGINT` column to a `TIMESTAMP` column. The `date` column in the `account` table is currently stored as a `BIGINT` representing the date in the format YYMMDD. The goal is to update this column to a `TIMESTAMP` type to store the date and time information.", "error_sql": ["\n    UPDATE account\n    SET date__timestamp = date__bigint::timestamp;\n    "], "sol_sql": ["\n    ALTER TABLE account\n    ALTER COLUMN date\n    TYPE varchar(30) \n    USING date::varchar;\n    ", "\n    ALTER TABLE account\n    ALTER COLUMN date\n    TYPE timestamp \n    USING date::timestamp;\n    "], "preprocess_sql": ["\n    ALTER TABLE account\n    ALTER COLUMN date\n    TYPE BIGINT\n    USING to_char(date, 'YYYYMMDD')::bigint;\n    "], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\n    \"\"\"\n    SELECT  data_type\n    FROM information_schema.columns\n    WHERE table_name = 'account'\n    AND column_name = 'date';\n    \"\"\"\n    ]\n    res, _, _ = execute_queries(queries,db_name,conn)\n    data_type = res[0][0]\n    assert 'timestamp' in data_type\n    "]}
{"instance_id": "341_2", "selected_database": "card_games", "query": "In the card_games database, there is a table named 'cards'. Each card is uniquely identified by a id and includes details about artists and bordercolors. The user wants to group the cards by their 'artist' attribute to get a distinct result for each group. However, when the user tries to use the following SQL query to achieve this, it results in an error or incorrect output: sql SELECT * FROM cards GROUP BY artist;  The user understands that this query is incorrect because it does not group by all the columns that need to be shown. The user is seeking a solution to this problem.", "error_sql": ["\n    SELECT * FROM cards GROUP BY artist;\n    "], "sol_sql": ["\n    select t1.*\n    from cards t1\n    join\n    (\n        SELECT min(id) as id\n        FROM cards\n        GROUP BY artist\n    ) t2 on t1.id = t2.id\n    "], "preprocess_sql": ["\n    DELETE FROM cards\n    WHERE artist NOT IN ('Ralph Horsley', 'Daarken');\n    ", "\n    DELETE FROM cards\n    WHERE artist IS NULL;\n    ", "\n    CREATE TABLE cards_new AS\n    SELECT id, artist, bordercolor\n    FROM cards;\n    DROP TABLE cards;\n    ALTER TABLE cards_new\n    RENAME TO cards;\n    "], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) == 2\n    artist_list = sorted([tup[1] for tup in pred_query_result])\n    assert artist_list == ['Daarken', 'Ralph Horsley']\n    "]}
{"instance_id": "351_1", "selected_database": "debit_card_specializing", "query": "I'm trying to create an SQL query that checks if a SELECT query on the 'transactions_1k' table returns no rows based on a specific criteria involving 'CustomerID' and 'Date'. If no rows are returned, it should then execute another SELECT query with a different criteria. Here's what I mean:\n\nsql\nIF SELECT * FROM transactions_1k WHERE CustomerID = 3 AND Date = '2012-08-24' RETURNS NO ROWS\nTHEN SELECT * FROM transactions_1k WHERE CustomerID = 7626 AND Date = '2012-08-24'\n\n\nIs this possible? I'm not sure if an empty result set counts as 'null', which is causing me some trouble.", "error_sql": ["IF SELECT * FROM transactions_1k WHERE CustomerID = 3 AND Date = '2012-08-24' RETURNS NO ROWS\nTHEN SELECT * FROM transactions_1k WHERE CustomerID = 7626 AND Date = '2012-08-24'"], "sol_sql": ["SELECT *\nFROM transactions_1k\nWHERE CustomerID = 3\n  AND Date = '2012-08-24'\n\nUNION ALL\n\nSELECT *\nFROM transactions_1k\nWHERE CustomerID = 7626\n  AND Date = '2012-08-24'\n  AND NOT EXISTS (\n    SELECT 1\n    FROM transactions_1k\n    WHERE CustomerID = 3\n      AND Date = '2012-08-24'\n  );\n    "], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "350_1", "selected_database": "financial", "query": "I need to compare the 'account' table with another table, but there are some columns in the 'account' table that I don't need to compare. Specifically, I want to exclude the 'account_id' and 'date' columns from the comparison. I tried to dynamically generate a SQL query to select all columns except these two, but the output SQL was incorrect. Here's the problematic SQL I used:", "error_sql": ["SELECT 'SELECT ' || array_to_string(ARRAY(SELECT 'o' || '.' || c.column_name\n    FROM information_schema.columns As c\n        WHERE table_name = 'account' \n        AND  c.column_name NOT IN('account_id', 'date')\n), ',') || ' FROM accountAs o' As sqlstmt"], "sol_sql": ["SELECT 'SELECT ' || STRING_AGG('a.' || column_name, ', ') || ' FROM account AS a' FROM information_schema.columns WHERE table_name = 'account' AND table_schema = 'public' AND column_name NOT IN ('account_id', 'date');"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_2 = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_2 = execute_queries(sol_sqls, db_name, conn)\n    pred_sqls_2 = remove_distinct(pred_sqls_2[0][0])\n    sol_sqls_2 = remove_distinct(sol_sqls_2[0][0])\n    result = ex_base(pred_sqls_2, sol_sqls_2, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "365_1", "selected_database": "financial", "query": "I have two tables: `account` and `loan`. I need to display the first 6 accounts from a specific district that has loans in the last 48 hours then the rest of the accounts. This works great but I get duplicates from the second query where I repeat these accounts again. I want to make sure `account.account_id` is unique.", "error_sql": ["(\n  SELECT\n    account.account_id,\n    account.frequency,\n    l.loan_id,\n    l.date AS loan_date,\n    0 AS priority\n  FROM account\n  LEFT JOIN loan l\n    ON account.account_id = l.account_id\n  WHERE account.district_id = '18'\n    AND l.date >= (NOW() - INTERVAL '48 hours')\n  ORDER BY l.date DESC NULLS LAST\n  LIMIT 6\n)\nUNION\n(\n  SELECT\n    account.account_id,\n    account.frequency,\n    l.loan_id,\n    l.date AS loan_date,\n    1 AS priority\n  FROM account\n  LEFT JOIN loan l\n    ON account.account_id = l.account_id\n  WHERE account.district_id = '18'\n  ORDER BY account.date DESC\n);"], "sol_sql": ["SELECT *\nFROM\n(\n  SELECT DISTINCT ON (account_id) *\n  FROM\n  (\n    (\n      SELECT\n        account.account_id,\n        account.frequency,\n        l.loan_id,\n        l.date AS loan_date,\n        0 AS priority\n      FROM account\n      LEFT JOIN loan l\n        ON account.account_id = l.account_id\n      WHERE account.district_id = '18'\n        AND l.date >= (NOW() - INTERVAL '48 hours')\n      ORDER BY l.date DESC NULLS LAST\n      LIMIT 6\n    )\n    UNION\n    (\n      SELECT\n        account.account_id,\n        account.frequency,\n        l.loan_id,\n        l.date AS loan_date,\n        1 AS priority\n      FROM account\n      LEFT JOIN loan l\n        ON account.account_id = l.account_id\n      WHERE account.district_id = '18'\n    )\n  ) t\n  ORDER BY account_id, priority\n) t\nORDER BY priority, loan_date DESC;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    return pred_sqls_result == sol_sqls_result"]}
{"instance_id": "352_2", "selected_database": "student_club", "query": "In the student_club database, there is a table named 'attendance' that records the attendance of members to various events. Each record in this table contains a 'link_to_event' which is a unique identifier for the event, and a 'link_to_member' which is a unique identifier for the member. The goal is to generate a  output that aggregates the attendance records by event, where each event's attendance is represented as an array of member objects. Each member object should contain the member's unique identifier ('link_to_member') and the event's unique identifier ('link_to_event'). The desired  output should be an array of these event-based arrays. However, the user encountered an issue where the output was interpreted as text, introducing undesired escape characters, and the outer array was missing. The user's query was adapted from a suggestion on another post, but it did not produce the desired result.", "error_sql": ["SELECT Array_agg(rw) FROM (SELECT link_to_event, (SELECT To_(Array_agg(Row_to_(t))) FROM (SELECT link_to_member FROM public.attendance WHERE link_to_event = b.link_to_event) t) rw FROM attendance b GROUP BY link_to_event);"], "sol_sql": ["SELECT json_agg(events_array) AS all_events\nFROM (\n  SELECT \n    json_agg(\n      json_build_object(\n        'link_to_member', link_to_member,\n        'link_to_event',  link_to_event\n      )\n    ) AS events_array\n  FROM attendance\n  GROUP BY link_to_event\n) sub;"], "preprocess_sql": "", "clean_up_sql": "", "test_cases": ["import json\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    def compare_array_of_arrays(arr1, arr2):\n        assert arr1 == arr2, \"The two array-of-array structures do not match.\"\n        return 1\n    \n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = compare_array_of_arrays(pred_query_result[0][0][0], sol_query_result[0][0][0])\n    return result"]}
{"instance_id": "362_1", "selected_database": "financial", "query": "In the financial database, we need to generate a list of all years between two given dates from the 'loan' table. The dates are extracted from the 'date' column, which represents the approval date of loans. The goal is to generate all years between the earliest and latest loan approval dates, regardless of the interval between them. For instance, if the earliest loan was approved on '1994-01-05' and the latest on '1997-12-08', we should get a list of years including '1994', '1995', '1996', and '1997'. However, the initial query only returns the starting year if the interval between the dates is less than a year, which is not the desired outcome.", "error_sql": ["SELECT to_char(generate_series, 'YYYY') FROM generate_series(MIN(date)::timestamptz, MAX(date)::timestamptz, '1 year') FROM loan;"], "sol_sql": ["SELECT generate_series(\n  EXTRACT(YEAR FROM MIN(date)::timestamptz AT TIME ZONE 'UTC')::int,\n  EXTRACT(YEAR FROM MAX(date)::timestamptz AT TIME ZONE 'UTC')::int\n)::text AS the_year\nFROM loan;"], "preprocess_sql": "", "clean_up_sql": "", "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    return pred_sqls_result == sol_sqls_result"]}
{"instance_id": "366_1", "selected_database": "financial", "query": "In the financial database, there is a table named 'loan' that records details of loans given to clients. Each loan is associated with an account, and the table contains columns such as 'loan_id', 'account_id', 'date', 'amount', 'duration', 'payments', and 'status'. The 'amount' column represents the loan amount in USD. The task is to retrieve all rows from the 'loan' table, along with an additional column that shows the maximum loan amount per account. This will help in understanding the highest loan amount each account has taken. However, the user attempted to use the ROW_NUMBER() window function to achieve this, which resulted in incorrect results.", "error_sql": ["SELECT account_id, amount FROM (SELECT account_id, amount, ROW_NUMBER() OVER(PARTITION BY account_id ORDER BY amount DESC) AS rn FROM loan) AS a WHERE rn = 1;"], "sol_sql": ["SELECT *, MAX(amount) OVER (PARTITION BY account_id) \"max\" FROM loan"], "preprocess_sql": "", "clean_up_sql": "", "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "242_2", "selected_database": "european_football_2", "query": "I am trying to filter matches based on certain conditions. Specifically, I want to select matches'id where the league's country ID is in a list of selected countries and the league ID is in a list of selected leagues. Additionally, if the match's country ID is 1, I want to further filter the matches based on a list of selected stages. However, my query is not working as expected. Short example: if a=0 then add some condition to WHERE (AND condition), if it's not then don't add (AND condition). Here is my query:", "error_sql": ["SELECT id FROM Match WHERE league_id = ANY (ARRAY[1, 1729, 4769]) AND country_id = ANY (ARRAY[1, 1729, 4769]) AND CASE WHEN country_id = 1 THEN stage = ANY (ARRAY[1, 11]) END"], "sol_sql": ["SELECT id FROM Match WHERE league_id = ANY (ARRAY[1, 1729, 4769]) AND country_id = ANY (ARRAY[1, 1729, 4769]) AND (country_id != 1 OR stage = ANY (ARRAY[1, 11]))"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "243_1", "selected_database": "financial", "query": "In the financial database, we need to create a table to store detailed information about clients, including their first name, last name, and a full name that is automatically generated from the first and last names. The full name should be stored as a generated column. However, when attempting to create the table with a generated column using the CONCAT function, an error occurs indicating that the generation expression is not immutable.", "error_sql": ["CREATE TABLE client_information ( client_id smallserial NOT NULL, first_name character varying(50), last_name character varying(50), full_name character varying(100) GENERATED ALWAYS AS (concat(first_name, ' ', last_name)) STORED, PRIMARY KEY (client_id) );"], "sol_sql": ["CREATE TABLE client_information ( client_id smallserial NOT NULL, first_name character varying(50), last_name character varying(50), full_name character varying(101) GENERATED ALWAYS AS  (CASE WHEN first_name IS NULL THEN last_name WHEN last_name  IS NULL THEN first_name ELSE first_name || ' ' || last_name END) STORED, PRIMARY KEY (client_id) );"], "preprocess_sql": [], "clean_up_sql": ["DROP TABLE IF EXISTS client_information;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_query_result_1 = execute_queries([\"SELECT table_name FROM information_schema.tables WHERE table_name = 'client_information';\"], db_name, conn)[0]\n    assert test_query_result_1[0][0] == 'client_information' , f\"Table client_information not found in database {test_query_result_1}.\"\n    insert_sql = execute_queries([\"INSERT INTO client_information (first_name, last_name) VALUES ('aaa', 'bbb');\"], db_name, conn);\n    test_query_result_2 = execute_queries([\"SELECT full_name FROM client_information WHERE first_name = 'aaa'\"], db_name, conn)[0]\n    assert test_query_result_2 == [('aaa bbb',)], f\"Full name not generated correctly. Found {test_query_result_2}\"\n    update_sql = execute_queries([\"UPDATE client_information SET last_name = 'ccc' WHERE first_name = 'aaa'\"], db_name, conn)\n    test_query_result_3 = execute_queries([\"SELECT full_name FROM client_information WHERE first_name = 'aaa'\"], db_name, conn)[0]\n    assert test_query_result_3 == [('aaa ccc',)], f\"Full name not generated correctly. Found {test_query_result_3}\""]}
{"instance_id": "244_1", "selected_database": "card_games", "query": "In the context of the card_games database, I frequently need to get a card's row based on its unique UUID, and if it does not exist, I want to create it and return its ID. For example, my table might be the 'cards' table. Suppose I want to insert a card with a specific UUID and name, and if the UUID already exists, I want to return the existing card's ID without modifying the row. However, using the following SQL statement, I encounter issues as it does not return the ID when the row already exists:\\nsql \\\\nINSERT INTO cards(uuid, name) VALUES ('5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 'Ancestor''s Chosen') \\\\nON CONFLICT DO NOTHING RETURNING id; \\\\n\\nThis statement does not return the ID of the existing row. I need a solution that returns the ID whether the row is inserted or already exists.", "error_sql": ["INSERT INTO cards(uuid, name) VALUES ('5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 'Ancestor''s Chosen') ON CONFLICT DO NOTHING RETURNING id;"], "sol_sql": ["WITH ins AS (INSERT INTO cards (uuid, name) VALUES ('5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 'Ancestor''s Chosen') ON CONFLICT (uuid) DO UPDATE SET uuid = NULL WHERE FALSE RETURNING id) SELECT id FROM ins UNION ALL SELECT id FROM cards WHERE uuid = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c' LIMIT 1;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) == 1, f'Expected 1 row, but found {len(pred_query_result)} rows'\n    assert pred_query_result[0][0] is not None, 'The returned ID should not be None'\n    test_pred_query_result_1 = execute_queries([\"SELECT id FROM cards WHERE uuid = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c';\"], db_name, conn)[0]\n    assert pred_query_result[0][0] == test_pred_query_result_1[0][0], f'Expected ID to match, but found {pred_query_result[0][0]} and {test_pred_query_result_1[0][0]}'\n"]}
{"instance_id": "245_1", "selected_database": "financial", "query": "In the financial database, I have a table `account` where I need to insert new records or update existing ones based on the `account_id`. The `date` column should be updated to the current date if the record already exists. I want to know whether an `INSERT` or an `UPDATE` operation was performed. I attempted to use an `ON CONFLICT..DO UPDATE` clause but encountered issues with determining the type of operation. I considered adding an `is_update` column to track this, but it feels unnecessary as it is not related to the data itself.", "error_sql": ["INSERT INTO account (account_id, district_id, frequency, date) VALUES (1, 18, 'POPLATEK MESICNE', CURRENT_DATE) ON CONFLICT (account_id) DO UPDATE SET date = CURRENT_DATE"], "sol_sql": ["INSERT INTO account (account_id, district_id, frequency, date) VALUES (1, 18, 'POPLATEK MESICNE', CURRENT_DATE) ON CONFLICT (account_id) DO UPDATE SET date = CURRENT_DATE RETURNING *, CASE WHEN xmax = 0 THEN 'INSERT' ELSE 'UPDATE' END AS operation_type;"], "preprocess_sql": [], "clean_up_sql": ["UPDATE account SET date = '1995-03-24'", "DELETE FROM account WHERE account_id = 22222"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    today = execute_queries([\"SELECT CURRENT_DATE\"], db_name, conn)[0][0][0]\n    assert len(pred_query_result) == 1, f'Expected 1 row, but found {len(pred_query_result)} rows'\n    assert pred_query_result[0][4] == 'UPDATE', f'Expected operation_type to be UPDATE, but found {pred_query_result[0][4]}'\n    assert pred_query_result[0][3] == today, f'Expected date is updated to today {today}, but found {pred_query_result[0][3]}'\n    test_query_result_1 = execute_queries([\"INSERT INTO account (account_id, district_id, frequency, date) VALUES (22222, 18, 'POPLATEK MESICNE', CURRENT_DATE) ON CONFLICT (account_id) DO UPDATE SET date = CURRENT_DATE RETURNING *, CASE WHEN xmax = 0 THEN 'INSERT' ELSE 'UPDATE' END AS operation_type;\"], db_name, conn)[0]\n    assert test_query_result_1[0][4] == 'INSERT', f'Expected operation_type to be INSERT, but found {test_query_result_1[0][4]}'"]}
{"instance_id": "247_2", "selected_database": "card_games", "query": "I am analyzing the release dates of Magic: The Gathering card sets to identify periods of consecutive releases. The data includes multiple entries for the same release date due to different printings or variations. I want to find the longest consecutive release periods along with their start and end dates. Here is the structure of the relevant table:\\n- id SERIAL, releaseDate DATE, setCode VARCHAR(50)\\nThe data could have equal release date entries:\\n- id 1, releaseDate 2019-12-28, setCode '10E'\\n- id 2, releaseDate 2019-12-28, setCode '10E'\\n- id 3, releaseDate 2019-12-29, setCode '10E'\\n- id 4, releaseDate 2019-12-29, setCode '10E'\\n- id 5, releaseDate 2019-12-31, setCode '10E'\\n- id 6, releaseDate 2019-12-31, setCode '10E'\\n- id 7, releaseDate 2020-01-01, setCode '10E'\\n- id 8, releaseDate 2020-01-01, setCode '10E'\\n- id 9, releaseDate 2020-01-02, setCode '10E'\\n- id 10, releaseDate 2020-01-03, setCode '10E'\\n- id 11, releaseDate 2020-01-04, setCode '10E'\\n- id 12, releaseDate 2020-01-04, setCode '10E'\\n- id 13, releaseDate 2020-01-05, setCode '10E'\\n- id 14, releaseDate 2020-01-22, setCode '10E'\\n- id 15, releaseDate 2020-01-29, setCode '10E'\\n- id 16, releaseDate 2020-01-30, setCode '10E'\\nI am interested in getting the consecutive release periods with the start and end dates. An output like this:\\n- count | date MIN | date MAX \\\\(6, 2019-12-31, 2020-01-05)\\\\(2, 2019-12-28, 2019-12-29)\\\\(2, 2020-01-29, 2020-01-30)\\nI tried the following SQL query, but it gives incorrect counts and mismatched start/end dates:\\", "error_sql": ["SELECT COUNT(*) -1 AS count, MAX(releaseDate), MIN(releaseDate) FROM (SELECT *, date(releaseDate) - row_number() OVER (PARTITION BY releaseDate ORDER BY date(releaseDate)) * INTERVAL '1 day' AS filter FROM sets_releaseInfo ) t1 GROUP BY filter HAVING COUNT(*) -1 > 0 ORDER BY count DESC"], "sol_sql": ["SELECT (MAX(releaseDate) - MIN(releaseDate)) + 1 AS cnt, MIN(releaseDate) AS date_min, MAX(releaseDate) AS date_max FROM (SELECT x.*, SUM(i) OVER(ORDER BY releaseDate) AS g FROM (SELECT t.*, CASE WHEN releaseDate > LAG(releaseDate) OVER(ORDER BY releaseDate) + 1 THEN 1 ELSE 0 END AS i FROM sets_releaseInfo t) x) y GROUP BY g;"], "preprocess_sql": ["CREATE TEMP TABLE sets_releaseInfo (id SERIAL, releaseDate DATE, setCode VARCHAR(50));", "INSERT INTO sets_releaseInfo (releaseDate, setCode) VALUES ('2019-12-28', '10E'), ('2019-12-28', '10E'), ('2019-12-29', '10E'), ('2019-12-29', '10E'), ('2019-12-31', '10E'), ('2019-12-31', '10E'), ('2020-01-01', '10E'), ('2020-01-01', '10E'), ('2020-01-02', '10E'), ('2020-01-03', '10E'), ('2020-01-04', '10E'), ('2020-01-04', '10E'), ('2020-01-05', '10E'), ('2020-01-22', '10E'), ('2020-01-29', '10E'), ('2020-01-30', '10E');"], "clean_up_sql": ["DROP TABLE IF EXISTS sets_releaseInfo;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "248_2", "selected_database": "card_games", "query": "In the card_games database, we have a table named 'collection' where each card can have a reference to another card through the 'nextCardId' column. This column represents the ID of the next card in a sequence. We want to generate a sequence path for each card starting from the card that has no previous card (i.e., no card points to it) and ending at the card that has no next card (i.e., its 'nextCardId' is NULL). The path should be represented as a string of card IDs separated by ' --> '.\\nFor example, if we have the following data:\\n| id  | nextCardId |\\n|-----|------------|\\n| 1   | 5          |\\n| 2   | NULL       |\\n| 3   | 6          |\\n| 4   | 7          |\\n| 5   | 8          |\\n| 6   | 9          |\\n| 7   | NULL       |\\n| 8   | NULL       |\\n| 9   | 10         |\\n| 10  | NULL       |\\nWe want to get the following paths:\\n1 --> 5 --> 8;\\n2;\\n3 --> 6 --> 9 --> 10;\\n4 --> 7;\\nHowever, when we run the following SQL query, we get incorrect results that include incomplete paths:\\nsql;\\nWITH RECURSIVE path_cte AS (\\n  SELECT id, nextCardId, id::TEXT AS Path;\\n  FROM collection\\n  WHERE nextCardId IS NULL\\n  UNION ALL\\n  SELECT collection.id, collection.nextCardId, collection.id || ' --> ' || cte.Path\\n  FROM collection\\n  JOIN path_cte cte ON collection.nextCardId = cte.id\\n)\\nSELECT Path\\nFROM path_cte\\nORDER BY id;\\n\\nWe need to correct this query to get only the complete paths starting from the cards that have no previous card and ending at the cards that have no next card.", "error_sql": ["WITH RECURSIVE path_cte AS (SELECT id, nextCardId, id::TEXT AS Path FROM collection WHERE nextCardId IS NULL UNION ALL SELECT collection.id, collection.nextCardId, collection.id || ' --> ' || cte.Path FROM collection JOIN path_cte cte ON collection.nextCardId = cte.id) SELECT Path FROM path_cte ORDER BY id;"], "sol_sql": ["WITH RECURSIVE path_cte AS (SELECT id, id::text AS Path, id AS FirstID, 1 AS Lvl FROM collection WHERE nextCardId IS NULL UNION ALL SELECT collection.id, collection.id::text || ' --> ' || cte.Path, cte.FirstId, cte.Lvl + 1 FROM collection JOIN path_cte cte ON collection.nextCardId = cte.id) SELECT DISTINCT ON (FirstID) Path FROM path_cte ORDER BY FirstID, Lvl DESC, id;"], "preprocess_sql": ["CREATE TABLE collection (id INTEGER NOT NULL PRIMARY KEY, nextCardId INTEGER)", "INSERT INTO collection (id, nextCardId) VALUES (1, 5), (2, NULL), (3, 6), (4, 7), (5, 8), (6, 9), (7, NULL), (8, NULL), (9, 10), (10, NULL);"], "clean_up_sql": ["DROP TABLE IF EXISTS collection"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "249_1", "selected_database": "financial", "query": "In the financial database, I need to classify transactions by quarter, but I want the quarters to start at a configurable month. If I set the quarter to start in April, then April, May, and June should be the first quarter. I think I need a function what_quarter_is(date_in, start_month). For example, what_quarter_is('1995-07-23', 4) = 2. The default EXTRACT(QUARTER FROM date) function in PostgreSQL starts quarters in January, which does not meet my requirements.", "error_sql": ["SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');"], "sol_sql": ["CREATE OR REPLACE FUNCTION what_quarter_is(date_in DATE, start_mon_in INTEGER DEFAULT 1) RETURNS INTEGER LANGUAGE sql AS $$ WITH RECURSIVE qtrs(mq, q, m, c) AS (SELECT 1, 1, start_mon_in, 1 UNION ALL SELECT mq % 3 + 1, CASE WHEN mq % 3 + 1 = 1 THEN q + 1 ELSE q END, CASE WHEN m = 12 THEN 1 ELSE m + 1 END, c + 1 FROM qtrs WHERE c < 12) SELECT q FROM qtrs WHERE m = EXTRACT(MONTH FROM date_in); $$;"], "preprocess_sql": [], "clean_up_sql": ["DROP FUNCTION what_quarter_is(date, integer);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_query_result_1 = execute_queries([\"SELECT proname, proargnames, prorettype::regtype, prosrc FROM pg_proc WHERE proname = 'what_quarter_is';\"], db_name, conn)[0]\n    assert len(test_query_result_1) == 1, f'Expected 1 row, but found {len(test_query_result_1)} row(s).'\n    test_query_result_2 = execute_queries([\"SELECT what_quarter_is('2024-01-01', 4)\"], db_name, conn)[0]\n    assert test_query_result_2[0][0] == 4, f'Expected 4, but found {test_query_result_2[0][0]}'\n    test_query_result_3 = execute_queries([\"SELECT what_quarter_is('2023-07-01', 2)\"], db_name, conn)[0]\n    assert test_query_result_3[0][0] == 2, f'Expected 2, but found {test_query_result_3[0][0]}.'"]}
{"instance_id": "264_2", "selected_database": "debit_card_specializing", "query": "In the context of a database specializing in debit card transactions, a user wants to calculate the total sum of multiple columns across all transactions without grouping by any specific column. The user initially attempted to use a query that groups by a specific column, which did not yield the desired result. The user's goal is to obtain a  object containing the total sums of the 'Amount', 'Price', and 'TransactionID' columns from the 'transactions_1k' table.", "error_sql": ["SELECT CustomerID, SUM(Amount) AS Amount, SUM(Price) AS Price, SUM(TransactionID) AS TransactionID FROM transactions_1k GROUP BY CustomerID;"], "sol_sql": ["SELECT SUM(Amount) AS Amount, SUM(Price) AS Price, SUM(TransactionID) AS TransactionID FROM transactions_1k;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "265_1", "selected_database": "codebase_community", "query": "In the codebase_community database, I have a table named 'users' with a primary key of 'id'. I need to find all tables, columns, and constraints that reference the 'users' table regardless of which column in 'users' is referenced. For example, if there is a table named 'posts' with a foreign key constraint as follows:\\nCREATE TABLE posts (\\n    id bigint NOT NULL,\\n    owneruserid bigint NULL,\\n    lasteditoruserid bigint NULL,\\n    PRIMARY KEY (id),\\n    FOREIGN KEY (owneruserid) REFERENCES users(id),\\n    FOREIGN KEY (lasteditoruserid) REFERENCES users(id)\\n);\\nI should get back rows like the following:\\nbase_table     base_col    referencing_table   referencing_col  constraint_sql\\nusers          id          posts               owneruserid        CONSTRAINT posts_owneruserid_fkey FOREIGN KEY (owneruserid) REFERENCES users(id)\\nusers          id          posts               lasteditoruserid   CONSTRAINT posts_lasteditoruserid_fkey FOREIGN KEY (lasteditoruserid) REFERENCES users(id)\\nNon-primary key references should also be listed and it should handle compound keys.", "error_sql": ["SELECT (select r.relname from pg_class r where r.oid = c.confrelid) as base_table,\\n       a.attname as base_col,\\n       (select r.relname from pg_class r where r.oid = c.conrelid) as referencing_table,\\n       UNNEST((select array_agg(attname) from pg_attribute where attrelid = c.conrelid and array[attnum] <@ c.conkey)) as referencing_col,\\n       pg_get_constraintdef(c.oid) contraint_sql  FROM pg_constraint c join pg_attribute a on c.confrelid=a.attrelid and a.attnum = ANY(confkey)\\n WHERE c.confrelid = (select oid from pg_class where relname = 'users')\\n   AND c.confrelid!=c.conrelid;"], "sol_sql": ["SELECT (select r.relname from pg_class r where r.oid = c.confrelid) as base_table, a.attname as base_col, (select r.relname from pg_class r where r.oid = c.conrelid) as referencing_table, UNNEST((select array_agg(attname) from pg_attribute where attrelid = c.conrelid and array[attnum] <@ c.conkey)) as referencing_col, pg_get_constraintdef(c.oid) contraint_sql  FROM pg_constraint c join pg_attribute a on c.confrelid=a.attrelid and a.attnum = ANY(confkey) WHERE c.confrelid = (select oid from pg_class where relname = 'users') AND c.confrelid!=c.conrelid;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "349_1", "selected_database": "financial", "query": "We have a table 'trans' that records all transactions made by clients in various accounts. Each transaction has a 'trans_id', 'account_id', 'date', 'type', 'operation', 'amount', 'balance', 'k_symbol', 'bank', and 'account'. We need to add a new column 'next_bank' to the 'trans' table that indicates the next non-null 'bank' value for each transaction, ordered by 'date' within each 'account_id'. For example, if a transaction has a null 'bank', the 'next_bank' should be the 'bank' of the next transaction in the same account that has a non-null 'bank'. The user attempted to use the following SQL query, which fails in PostgreSQL due to the lack of support for the 'ignore nulls' clause in the window function. The query is as follows:", "error_sql": ["SELECT first_value(bank ignore nulls) over (partition by account_id order by date rows unbounded following) as next_bank FROM trans;"], "sol_sql": ["SELECT bank, first_value(bank) over (partition by account_id order by date rows between current row and unbounded following) as next_bank FROM trans WHERE bank is not null ORDER BY account_id, date;"], "preprocess_sql": "ALTER TABLE trans ADD COLUMN next_amount int;", "clean_up_sql": "ALTER TABLE trans DROP COLUMN next_amount;", "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "436_1", "selected_database": "financial", "query": "In the financial database, there are two tables, `account` and `loan`. The `account` table contains multiple entries representing various bank accounts, while the `loan` table is currently empty as no loans have been issued yet. The following query correctly returns the expected result, namely `account_count` larger than `0`:\\nsql \\\\\\\\nSELECT COUNT(DISTINCT account_id) AS count_a FROM account \\\\\\\\n\\nHowever, the following query returns `0` for both `count_a` and `count_b`:\\nsql \\\\\\\\nSELECT COUNT(DISTINCT a.account_id) AS count_a, COUNT(DISTINCT l.account_id) AS count_b FROM account a, loan l \\\\\\\\n\\nWhat is the correct way to write the query so that `count_a` contains the correct (expected) value > `0`, whereas `count_b` is `0`?", "error_sql": ["SELECT COUNT(DISTINCT a.account_id) AS count_a, COUNT(DISTINCT l.account_id) AS count_b FROM account a, loan l;"], "sol_sql": ["SELECT (SELECT COUNT(DISTINCT account_id) FROM account) AS count_a, (SELECT COUNT(DISTINCT account_id) FROM loan) AS count_b;"], "preprocess_sql": ["TRUNCATE TABLE loan CASCADE;"], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "437_1", "selected_database": "european_football_2", "query": "I have two separate queries that I want to combine. The first query retrieves the team_api_id and short names of teams from the Team table. The second query retrieves the buildUpPlaySpeed from the Team_Attributes table, based on the team_api_id. I want to combine these two queries into a single query that outputs theteam_api_id, team long name, and the corresponding buildUpPlaySpeed. I have tried the following sql: \\nsql \\\\\\\\nSELECT team_api_id, team_short_name FROM Team as data FULL OUTER JOIN ( SELECT buildUpPlaySpeed, team_api_id FROM Team_Attributes ta WHERE team_api_id = data.team_api_id ) AS subquery_alias ON data.team_api_id = subquery_alias.team_api_id; \\\\\\\\n\\n However, when I ran this query, I encountered an error: There is an entry for table 'data' but it cannot be referenced from this part of the query. How can I modify my query so that it properly combines the results of the two queries?", "error_sql": ["SELECT team_api_id, team_short_name FROM Team as data FULL OUTER JOIN (SELECT buildUpPlaySpeed, team_api_id FROM Team_Attributes ta WHERE team_api_id = data.team_api_id) AS subquery_alias ON data.team_api_id = subquery_alias.team_api_id;"], "sol_sql": ["SELECT t1.team_api_id, t1.team_short_name, t2.buildUpPlaySpeed FROM Team t1 INNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "439_1", "selected_database": "financial", "query": "We have two tables in our financial database: `trans` and `loan`. The `trans` table records all transactions made by clients, while the `loan` table records all loans issued to clients. Each transaction and loan has a timestamp indicating when it occurred. We want to combine these two tables into a single dataset, without worrying about clashing IDs, and then count the number of actions (transactions and loans) per year. The goal is to produce a result set that shows the total number of actions in each year (order by year). I attempted to write a query but encountered an error related to the GROUP BY clause.", "error_sql": ["WITH one AS ( SELECT date_trunc('year', date) as timeOne, COUNT(*) as trans_count FROM trans ORDER BY timeOne ), two AS ( SELECT date_trunc('year', date) as timeTwo, COUNT(*) as loan_count FROM loan ORDER BY timeTwo ) SELECT timeOne as year, SUM(trans_count, loan_count) as count FROM one, two ORDER BY 1;"], "sol_sql": ["WITH years AS ( SELECT date_trunc('year', date) as year, COUNT(*) as count FROM trans GROUP BY 1 UNION ALL SELECT date_trunc('year', date) as year, COUNT(*) as count FROM loan GROUP BY 1 ) SELECT year, SUM(count) as count FROM years GROUP BY year ORDER BY year;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "440_1", "selected_database": "financial", "query": "We want to display a list of districts along with the first/random client associated with each district. The initial approach might involve using MIN(client_id) and MIN(birth_date) to select the first client, but this could lead to inconsistencies as MIN(client_id) and MIN(birth_date) might refer to different clients. We need a more reliable method to fetch just one client per district.", "error_sql": ["SELECT district.district_id, district.a2, MIN(client.client_id) AS client_id, MIN(client.birth_date) AS birth_date FROM district LEFT OUTER JOIN client ON (client.district_id = district.district_id) GROUP BY district.district_id;"], "sol_sql": ["SELECT distinct on (d.district_id) d.district_id, d.a2, c.client_id AS client_id, c.birth_date AS birth_date FROM district d LEFT OUTER JOIN client c ON c.district_id = d.district_id ORDER BY d.district_id, c.client_id;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result, _, _ = execute_queries(pred_sqls, 'financial', conn)\n    expected_row_count = 77\n    actual_row_count = len(pred_query_result)\n    assert actual_row_count == expected_row_count, (f'Expected {expected_row_count} rows, but found {actual_row_count} rows.')\n\n    for row in pred_query_result:\n        district_id, a2, client_id, birth_date = row\n        district_query = [f\"SELECT a2 FROM district WHERE district_id = {district_id};\"]\n        district_result, _, _ = execute_queries(district_query, 'financial', conn)\n        assert district_result, (f\"No matching district found for district_id = {district_id}.\")\n        expected_a2 = district_result[0][0]\n        assert a2 == expected_a2, (f\"For district_id {district_id}, expected a2 = {expected_a2}, but found a2 = {a2}.\")\n        \n        client_query = [f\"SELECT birth_date FROM client WHERE client_id = {client_id};\"]\n        client_result, _, _ = execute_queries(client_query, 'financial', conn)\n        assert client_result, (f\"No matching client found for client_id = {client_id} in district_id = {district_id}.\")\n        expected_birth_date = client_result[0][0]\n        assert birth_date == expected_birth_date, (f\"For client_id {client_id}, expected birth_date = {expected_birth_date}, \" f\"but found birth_date = {birth_date}.\")\n    "]}
{"instance_id": "389_1", "selected_database": "debit_card_specializing", "query": "In the context of the debit_card_specializing database, we need to draw the first place to fifth place winners from a pool of customers based on their transaction amounts. A customer can't win multiple places. If a customer hasn't placed, then all of their transaction amounts must be considered in the draw. The goal is to draw all five place winners efficiently without repeating the query multiple times. The transactions_1k table contains the necessary data with columns such as CustomerID and Amount. The user initially attempted to draw one winner but couldn't extend the logic to draw all five winners without eliminating previous winners in each subsequent draw.", "error_sql": ["WITH gen_transactions AS (SELECT CustomerID, Amount FROM transactions_1k CROSS JOIN LATERAL generate_series(1, CAST(Amount AS INTEGER))), shuffle AS (SELECT CustomerID, Amount, row_number() OVER (ORDER BY random()) AS rn FROM gen_transactions) SELECT * FROM shuffle ORDER BY RANDOM() LIMIT 1;"], "sol_sql": ["WITH gen_transactions AS (SELECT CustomerID, Amount FROM transactions_1k CROSS JOIN LATERAL generate_series(1, CAST(Amount AS INTEGER))), shuffle AS (SELECT CustomerID, Amount, row_number() OVER (ORDER BY random()) AS rn FROM gen_transactions) SELECT CustomerID, Amount FROM shuffle WHERE rn <= 5 ORDER BY rn;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 5, f'Expected 5 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(set(row[0] for row in pred_query_result)) == 5, 'All CustomerIDs should be unique'\n    "]}
{"instance_id": "391_2", "selected_database": "card_games", "query": "The data in the table test includes one column named \" observation\". I am using postgres and I have multiple entries of jsonb inside an array in a single column called observation. They're input as '[{\"a\": 1}, {\"b\": 2}, {\"c\": 0.5}]'::jsonb. There are multiple rows, with multiple json elements inside of each one of them. I would like to combine them into one big entry in one row, so that I will just have one observation of one column as a result.", "error_sql": ["INSERT INTO test(observation) SELECT jsonb_agg(observation) FROM (SELECT observation FROM test) AS subquery; SELECT * FROM test;"], "sol_sql": ["\nINSERT INTO test(observation)\nSELECT jsonb_agg(s.elements)\nFROM (\n  SELECT jsonb_array_elements(observation) FROM test\n) AS s(elements);\n\nSELECT * FROM test;\n"], "preprocess_sql": ["\nCREATE TABLE test (observation JSONB); \nINSERT INTO test (observation) VALUES \n('[{\"a\": 1}, {\"b\": 2}, {\"c\": 0.5}]'::jsonb), \n('[{\"d\": 2.2}, {\"e\": 2.4}, {\"f\": 3.5}]'::jsonb), \n('[{\"g\": 1.7}, {\"h\": 5.4}, {\"i\": 8.9}]'::jsonb);\nSELECT * FROM test;\n"], "clean_up_sql": ["DROP TABLE test;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[3][0]\n    assert isinstance(concatenated_json, list), f'Expected result to be a list, but found {type(concatenated_json)}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[3][0]\n    expected_json_length = 9 \n    assert len(concatenated_json) == expected_json_length, f'Expected {expected_json_length} elements, but found {len(concatenated_json)} elements'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[3][0]\n    expected_values = [\n        {\"a\": 1}, {\"b\": 2}, {\"c\": 0.5},\n        {\"d\": 2.2}, {\"e\": 2.4}, {\"f\": 3.5},\n        {\"g\": 1.7}, {\"h\": 5.4}, {\"i\": 8.9}\n    ]\n    assert concatenated_json == expected_values, f'Expected {expected_values} but found {concatenated_json}'\n    "], "external_data": "{\"a\": 1}, {\"b\": 2}, {\"c\": 0.5},{\"d\": 2.2}, {\"e\": 2.4}, {\"f\": 3.5},{\"g\": 1.7}, {\"h\": 5.4}, {\"i\": 8.9}"}
{"instance_id": "403_1", "selected_database": "financial", "query": "In the financial database, I have two tables: `trans` and `account`. The `trans` table contains transaction details including the `account_id`, `date`, `type`, `operation`, `amount`, `balance`, `k_symbol`, `bank`, and `account`. The `account` table contains account details including `account_id`, `district_id`, `frequency`, and `date`. For each transaction in the `trans` table that matches a specific `account_id` and `type`, I want to join the corresponding record in the `account` table with the minimum transaction date. I want to group the results by `k_symbol` and extract the `k_symbol`, `operation`, `amount`,  `balance`, and `frequency` from the selected transaction record.", "error_sql": ["SELECT t.k_symbol, t.operation, t.amount, t.balance, a.frequency FROM trans t INNER JOIN account a ON t.account_id = a.account_id WHERE t.account_id = 1 AND t.type = 'PRIJEM' GROUP BY t.k_symbol -- and t.date is the minimum for each group;"], "sol_sql": ["\nSELECT t.k_symbol, t.operation, t.amount, t.balance, a.frequency\nFROM (\n    SELECT DISTINCT ON (t.k_symbol) \n           t.k_symbol, t.operation, t.amount, t.balance, t.account_id, t.date\n    FROM trans t\n    WHERE t.account_id = 1\n    AND t.type = 'PRIJEM'\n    ORDER BY t.k_symbol, t.date\n) t\nINNER JOIN account a ON t.account_id = a.account_id LIMIT 100\n"], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    \n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    row_with_UROK = [i for i, row in enumerate(pred_query_result) if row[0] == 'UROK']\n    row_n = row_with_UROK[0]\n    assert pred_query_result[row_n][1] is None, f'Expected operation to be NULL, but found {pred_query_result[row_n][1]}'\n    assert pred_query_result[row_n][2] == 19, f'Expected amount to be 19, but found {pred_query_result[row_n][2]}'\n    assert pred_query_result[row_n][3] == 17298, f'Expected balance to be 17298, but found {pred_query_result[row_n][3]}'\n    assert pred_query_result[row_n][4] == 'POPLATEK MESICNE', f'Expected frequency to POPLATEK MESICNE, but found {pred_query_result[row_n][4]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    row_with_NULL = [i for i, row in enumerate(pred_query_result) if row[0] is None]\n    row_n = row_with_NULL[0]\n    assert pred_query_result[row_n][1] == 'VKLAD', f'Expected operation to be VKLAD, but found {pred_query_result[row_n][1]}'\n    assert pred_query_result[row_n][2] == 1000, f'Expected amount to be 1000, but found {pred_query_result[row_n][2]}'\n    assert pred_query_result[row_n][3] == 1000, f'Expected balance to be 1000, but found {pred_query_result[row_n][3]}'\n    assert pred_query_result[row_n][4] == 'POPLATEK MESICNE', f'Expected frequency to POPLATEK MESICNE, but found {pred_query_result[row_n][4]}'\n    "]}
{"instance_id": "396_2", "selected_database": "card_games", "query": "I am trying to analyze the purchasing behavior of users in our card_games database to find out the count of sequential monthly purchases and their lengths for each user. Below is a simplified structure of my table and my expected end result. I want to identify the longest streaks of consecutive monthly purchases for each user and then count how many users have each longest streak length. For example, if a user made purchases in March, April, May, and June, that would be a streak of 4 months. If another user made purchases in January, February, and March, that would be a streak of 3 months. I need to find the longest streak for each user and then count how many users have the longest streak of a certain length. The expected result should show the streak length and the number of users who have that longest streak length.", "error_sql": ["SELECT user_id, COUNT(*) AS num_consecutive_months FROM (SELECT user_id, action_date, DATE_TRUNC('month', TO_DATE(action_date || '-01', 'YYYY-MM-DD')) AS month_date, ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY DATE_TRUNC('month', TO_DATE(action_date || '-01', 'YYYY-MM-DD'))) - ROW_NUMBER() OVER(PARTITION BY user_id, DATE_TRUNC('month', TO_DATE(action_date || '-01', 'YYYY-MM-DD')) - INTERVAL '1 month' * ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY DATE_TRUNC('month', TO_DATE(action_date || '-01', 'YYYY-MM-DD')))) AS grp FROM user_actions) sub GROUP BY user_id, grp ORDER BY COUNT(*) DESC LIMIT 1;"], "sol_sql": ["\nWITH cte AS (\n    SELECT user_id, \n           TO_DATE(action_date || '-01','YYYY-MM-DD') AS date_as_date\n    FROM user_actions\n), islands AS ( \n    SELECT *, \n           CASE WHEN LAG(date_as_date) OVER(PARTITION BY user_id ORDER BY date_as_date) + INTERVAL '1 month' <> date_as_date\n                THEN 1 ELSE 0 \n           END AS new_partition\n    FROM cte\n), partitioned_islands AS (\n    SELECT user_id, \n           SUM(new_partition) OVER(PARTITION BY user_id ORDER BY date_as_date) AS partitions\n    FROM islands\n), count_per_island AS (\n    SELECT COUNT(*) AS num_consecutive_dates\n    FROM partitioned_islands\n    GROUP BY user_id, partitions\n    ORDER BY ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY COUNT(*) DESC)\n    FETCH FIRST 1 ROWS WITH TIES\n)\nSELECT num_consecutive_dates AS streakLength, \n       COUNT(*) AS numOfOccurrences  \nFROM count_per_island\nGROUP BY streakLength\nORDER BY streakLength DESC\n"], "preprocess_sql": ["CREATE TABLE user_actions ( action_date VARCHAR(255), user_id VARCHAR(255) ); INSERT INTO user_actions(action_date, user_id) VALUES('2020-03', 'alex01'), ('2020-04', 'alex01'), ('2020-05', 'alex01'), ('2020-06', 'alex01'), ('2020-12', 'alex01'), ('2021-01', 'alex01'), ('2021-02', 'alex01'), ('2021-03', 'alex01'), ('2020-04', 'jon03'), ('2020-05', 'jon03'), ('2020-06', 'jon03'), ('2020-09', 'jon03'), ('2021-11', 'jon03'), ('2021-12', 'jon03'), ('2022-01', 'jon03'), ('2022-02', 'jon03'), ('2020-05', 'mark05'), ('2020-06', 'mark05'), ('2020-07', 'mark05'), ('2020-08', 'mark05'), ('2020-09', 'mark05');"], "clean_up_sql": ["DROP TABLE user_actions;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][0] == 5, f'Expected longest streak length to be 5, but found {pred_query_result[0][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][1] == 1, f'Expected 1 user with longest streak of 5 months, but found {pred_query_result[0][1]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[1][0] == 4, f'Expected longest streak length to be 4, but found {pred_query_result[1][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[1][1] == 2, f'Expected 2 users with longest streak of 4 months, but found {pred_query_result[1][1]}'\n    "]}
{"instance_id": "398_1", "selected_database": "financial", "query": "I have a table named \"test\" with columns \"ku\", \"item\" and \"l1m_visits\". I am trying to retrieve records based on a custom field \"ci_ku\". For the same values of \"ci_ku\" we will be having multiple \"l1m_visits\", and I want to retrieve the minimum value of \"l1mvisits\" for each \"ci_ku\". and i want to get the ci_ku by removing the string between 1st and 2nd underscore(-) in ku, how to write a query to get the ci_ku here.", "error_sql": ["\nWITH tab_with_ci_ku AS (\n   select split(ku, '-', 3)ivm_arr,\n\n           l1m_visits,\n           last_refresh_date\n    FROM db.scema.table\n), ranked_visits AS (\n    SELECT *, ROW_NUMBER() OVER(PARTITION BY CONCAT(ivm_arr[2],item) as ci_sku ORDER BY l1m_visits) AS rn\n    FROM tab_with_ci_ku\n)\nSELECT sku,ci_ku\nFROM ranked_visits\nWHERE rn = 1\n"], "sol_sql": ["\nWITH tab_with_ci_ku AS (\n    SELECT *, \n           REGEXP_REPLACE(ku, '([^-]+)-[^-]+-(.*)', '\\1-\\2') AS ci_ku\n    FROM test\n),\nranked_visits AS (\n    SELECT *, \n           ROW_NUMBER() OVER (PARTITION BY ci_ku ORDER BY l1m_visits) AS rn\n    FROM tab_with_ci_ku\n)\nSELECT ku, ci_ku, l1m_visits\nFROM ranked_visits\nWHERE rn = 1\n"], "preprocess_sql": ["\nCREATE TABLE test (\n    ku VARCHAR(50),\n    item VARCHAR(10),\n    l1m_visits CHAR(1)\n);\n\nINSERT INTO test (ku, item, l1m_visits) VALUES\n('1234-5678-HIJK', '1234', 'A'),\n('1234-9012-HIJK', '1234', 'B'),\n('56457-12456-DF-GH-TC', '56457', 'D');\n"], "clean_up_sql": ["DROP TABLE test;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][1] == '1234-HIJK', f'Expected ci_ku to be 1234-HIJK, but found {pred_query_result[0][1]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][2] == 'A', f'Expected l1m_visits to be A, but found {pred_query_result[0][2]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[1][1] == '56457-DF-GH-TC', f'Expected ci_ku to be 56457-DF-GH-TC, but found {pred_query_result[1][1]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[1][2] == 'D', f'Expected l1m_visits to be D, but found {pred_query_result[1][2]}'\n    "]}
{"instance_id": "266_2", "selected_database": "european_football_2", "query": "Suppose we have the following table in the 'european_football_2' database that records the overall rating of players over time:\\n|player_api_id|date|overall_rating|\\n|-------------|----|--------------|\\n|505942       |2016-02-18|67          |\\n|505942       |2015-11-19|67          |\\n|505942       |2015-09-21|62          |\\n|155782       |2016-03-15|75          |\\n|155782       |2015-12-10|74          |\\n|162549       |2016-01-20|70          |\\n|162549       |2015-10-25|68          |\\nFor each player, we want the latest overall rating based on the date. The final table would be:\\n|player_api_id|date|overall_rating|\\n|-------------|----|--------------|\\n|505942       |2016-02-18|67          |\\n|155782       |2016-03-15|75          |\\n|162549       |2016-01-20|70          |\\nI attempted to group by player_api_id while ordering by date and then getting the first value:\\nsql \\\\nSELECT player_api_id, MAX(date), FIRST(overall_rating) \\\\nFROM Player_Attributes \\\\nGROUP BY player_api_id \\\\nORDER BY date desc \\\\n\\nBut this doesn't work.", "error_sql": ["SELECT player_api_id, MAX(date), FIRST(overall_rating) FROM Player_Attributes GROUP BY player_api_id ORDER BY date desc;"], "sol_sql": ["SELECT player_api_id, date, overall_rating FROM Player_Attributes ORDER BY ROW_NUMBER() OVER(PARTITION BY player_api_id ORDER BY date DESC) FETCH FIRST 1 ROWS WITH TIES;"], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "251_2", "selected_database": "codebase_community", "query": "I am using a tool that allows querying user data in our local database using the PostgreSQL interface. I am running a simple query to print all ages of the users on our platform. However, I am getting an error message that says 'ERROR:  invalid input syntax for type numeric: \"text\"'. I am not sure why I am getting this error. Can you help me understand why this error is occurring and how I can fix it?", "error_sql": ["SELECT Age::numeric FROM users;"], "sol_sql": ["CREATE OR REPLACE FUNCTION get_user_ages() RETURNS setof numeric AS $BODY$ DECLARE curr_age  text; BEGIN FOR curr_age IN SELECT Age FROM users LOOP BEGIN RETURN NEXT curr_age::numeric; EXCEPTION WHEN OTHERS THEN NULL; END; END LOOP; END $BODY$  LANGUAGE plpgsql; SELECT * FROM get_user_ages();"], "preprocess_sql": ["ALTER TABLE users ALTER COLUMN Age SET DATA TYPE text; INSERT INTO users VALUES (1212121,3150,'2010-07-19 19:09:39','JMS','2014-09-13 04:03:25',NULL,NULL,NULL,257,138,7,134002,'Invalid Age',NULL);"], "clean_up_sql": ["DELETE FROM users WHERE id = 1212121; ALTER TABLE users ALTER COLUMN age SET DATA TYPE integer USING age::integer;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res, _, _ = execute_queries([\"SELECT count(*) FROM users;\"], db_name, conn)\n    ori_count = res[0][0]\n    res, _, _ = execute_queries([\"SELECT count(*) FROM get_user_ages();\"], db_name, conn)\n    next_count = res[0][0]\n    assert next_count ==  (ori_count-1), f'Expected 40325 row in get_user_ages table, got {next_count}'\n    res,_, _ = execute_queries([\"SELECT count(get_user_ages) FROM get_user_ages() where get_user_ages = 31 GROUP BY get_user_ages order by get_user_ages;\"], db_name,conn)\n    init_res = res[0][0]\n    res, _, _ = execute_queries([\"select count(age) from users where age = '31' group by age order by age ;\"], db_name,conn)\n    other_res = res[0][0]\n    assert init_res == other_res, f'Expected same result, got {init_res} and {other_res}'\n    \n"]}
{"instance_id": "257_1", "selected_database": "codebase_community", "query": "In our local database, we have two tables `users` and `profiles`. When a new user is added to the `users` table, we want to automatically create a corresponding profile in the `profiles` table. The `profiles` table has three columns: `id`, `CreationDate`, and `WebsiteUrl`. The `WebsiteUrl` should be derived from the user's WebsiteUrl by taking the part before the '.com'  and after the 'http://'. For example, 'http://stackoverflow.com' should become 'stackoverflow'. To achieve this, I created a trigger on the `users` table with the following function: sql begin insert into profiles (Id, CreationDate, WebsiteUrl) select new.id, new.WebsiteUrl, left(replace(new.WebsiteUrl, '.', '-'), charindex('@', replace(new.WebsiteUrl, '.', '-')) - 1); return new; end;  However, when a new user is added, I encounter the error:  ERROR: function charindex(unknown, text) does not exist (SQLSTATE 42883)", "error_sql": ["begin insert into profiles (Id, CreationDate, WebsiteUrl) select new.Id, new.CreationDate, left(replace(new.WebsiteUrl, '.', '-'), charindex('@', replace(new.WebsiteUrl, '.', '-')) - 1); return new; end;"], "sol_sql": ["CREATE OR REPLACE FUNCTION profileTrigger() RETURNS TRIGGER AS $profile_table$ begin insert into profiles (id, CreationDate, WebsiteUrl) select new.Id, new.CreationDate, left(right(new.WebsiteUrl, char_length(new.WebsiteUrl) - 7), strpos(right(new.WebsiteUrl, char_length(new.WebsiteUrl) - 7), '.')-1);return new; end; $profile_table$ LANGUAGE plpgsql; CREATE TRIGGER profile_table AFTER INSERT ON users FOR EACH ROW EXECUTE PROCEDURE profileTrigger();"], "preprocess_sql": ["DROP TABLE IF EXISTS profiles; CREATE TABLE profiles (id varchar(256) NOT NULL, CreationDate text, WebsiteUrl text, PRIMARY KEY (id));"], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    check_sql = [\"INSERT INTO users VALUES (341111,185,'2010-07-19 19:11:11','Christopher D. Long','2014-09-13 00:02:35','http://angrystatistician.blogspot.com','Versailles, KY','<p>Consulting analyst for the San Diego Padres, Houston Rockets.</p><p>Twitter:</a></p><p>LinkedIn/p>',27,23,0,509455,NULL,'http://i.stack.imgur.com/km1pr.jpg')\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([\"SELECT * FROM profiles LIMIT 1;\"], db_name,conn)\n    res_id, res_CreationDate, res_WebsiteUrl = res[0][0], res[0][1], res[0][2]\n    assert len(res) == 1, f\"Expected 1 row in profiles table, got {len(res)}\"\n    assert res_id == '341111', f\"Expected id to be '341111', got {res_id}\"\n    assert res_WebsiteUrl == 'angrystatistician', f\"Expected WebsiteUrl to be 'angrystatistician', got {res_WebsiteUrl}\"\n    \n"]}
{"instance_id": "237_1", "selected_database": "financial", "query": "We have a large transaction table in our financial database with over 180 million rows and 20 GB in size. The table is structured to store detailed transaction records for various accounts. We are running a query to retrieve specific transactions based on a list of account IDs, a specific bank, and a range of transaction types. The query is taking an unexpectedly long time to execute when the shared buffers are cold, around 9 seconds, but only 25 ms when the data is cached. We suspect that the query planner is not choosing the most optimal execution plan. We have tried adding a covering index and forcing a Bitmap Heap Scan, but we would like to understand why the planner is not making the best choice and find a more permanent solution to improve performance to around 1-2 seconds.", "error_sql": ["SELECT t.trans_id,       t.account_id,       t.date,       t.type,       t.amount  FROM trans t  JOIN account a    ON t.account_id = a.account_id WHERE a.district_id = 18   AND t.bank = 'AB'  AND t.type IN ('PRIJEM', 'VYDAJ')"], "sol_sql": ["DROP INDEX IF EXISTS idx_trans_account_bank_type", "CREATE INDEX idx_trans_account_bank_type ON trans (account_id, bank, type);", "ANALYZE trans;", "SELECT trans_id, account_id, date, type, amount FROM trans WHERE account_id IN (SELECT account_id FROM account WHERE district_id = 18) AND bank = 'AB' AND type IN ('PRIJEM', 'VYDAJ')"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "], "efficiency": true}
{"instance_id": "441_2", "selected_database": "card_games", "query": "A user is working with a table named `cards` in the `card_games` database. They want to find card records that match specific criteria: `availability` is 'paper', `bordercolor` is 'black', `rarity` is 'uncommon', and `type` is 'Creature'. They can write a query to get rows that match all these conditions. However, they also want to find cards that meet 3 out of these 4 criteria. Can this be done in a single SQL query?", "error_sql": ["SELECT * FROM cards WHERE availability = 'paper' AND bordercolor = 'black' AND rarity = 'uncommon' AND types = 'Creature';"], "sol_sql": ["SELECT * FROM cards WHERE  3 = (CASE WHEN availability = 'paper' THEN 1 ELSE 0 END) + (CASE WHEN bordercolor = 'black' THEN 1 ELSE 0 END) + (CASE WHEN rarity = 'uncommon' THEN 1 ELSE 0 END) + (CASE WHEN types = 'Creature' THEN 1 ELSE 0 END);"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "444_2", "selected_database": "card_games", "query": "I need to remove all cards from the 'cards' table that from the same artist. The provided SQL query only deletes duplicates but leaves one instance of each duplicate artist name. I want to remove all instances of any artist name (not NULL) that appears more than once in the table.", "error_sql": ["DELETE FROM cards c1 USING cards c2 WHERE c1.artist = c2.artist AND c1.id < c2.id;"], "sol_sql": ["DELETE FROM cards WHERE artist IN (SELECT artist FROM cards GROUP BY artist HAVING COUNT(*) > 1);"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    total_rows_query = [\"SELECT COUNT(*) FROM cards;\"]\n    number, _, _ = execute_queries(total_rows_query, db_name, conn)\n    expected_row_count = 193\n    actual_row_count = number[0][0]\n    assert actual_row_count == expected_row_count, (f'Expected {expected_row_count} rows, but found {actual_row_count} rows.')\n\n    duplicate_count_query = [\"SELECT COUNT(*) FROM (SELECT artist FROM cards WHERE artist <> NULL GROUP BY artist HAVING COUNT(*) > 1) AS duplicates;\"]\n    duplicates, _, _ = execute_queries(duplicate_count_query, db_name, conn)\n    dup = duplicates[0][0]\n    assert dup == 0, (f'Expected 0 duplicate artists after sol_sql, but found {dup} duplicates.')\n    "]}
{"instance_id": "442_3", "selected_database": "student_club", "query": "I want to insert a new event into the 'event' table and, in case of a duplicate event ID (which is unique), log the failure in the 'failure' table with specific event ID and member ID indicating the error. For example, I want to insert an event with the ID 'recAlAwtBZ0Fqbr5K' and name 'Annual Gala'. If it fails due to a duplicate name, log the failure with the member ID 'rec280Sk7o31iG0Tx'. My current SQL statement is producing an error: syntax error at or near 'insert'.", "error_sql": ["insert into event (event_id, event_name, event_date, type, notes, location, status) values ('recAlAwtBZ0Fqbr5K', 'Annual Gala', '2023-12-15T19:00:00', 'Social', 'Annual Gala for club members', 'Grand Ballroom', 'Open') on conflict (event_id) do insert into failure (event, member) values ('recAlAwtBZ0Fqbr5K', 'rec280Sk7o31iG0Tx');"], "sol_sql": ["WITH j AS (INSERT INTO event (event_id, event_name, event_date, type, notes, location, status) VALUES ('recAlAwtBZ0Fqbr5K', 'Annual Gala', '2023-12-15T19:00:00', 'Social', 'Annual Gala for club members', 'Grand Ballroom', 'Open') ON CONFLICT (event_id) DO UPDATE SET event_id = event.event_id RETURNING xmax = 0 AS inserted, *) INSERT INTO failure (event, member) SELECT event_id, 'rec280Sk7o31iG0Tx' FROM j WHERE NOT inserted RETURNING *;"], "preprocess_sql": ["CREATE TABLE failure (event VARCHAR(255) NOT NULL, member VARCHAR(255) NOT NULL, PRIMARY KEY (event, member));"], "clean_up_sql": ["DROP TABLE IF EXISTS failure;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1, _, _ = execute_queries([\"SELECT event FROM failure;\"], db_name, conn)\n    pred_query_result_2, _, _  = execute_queries([\"SELECT member FROM failure;\"], db_name, conn)\n    assert len(pred_query_result_1) == 1, f'Expected 1 rows, but found {len(pred_query_result_1)} rows' \n    assert len(pred_query_result_2) == 1, f'Expected 1 rows, but found {len(pred_query_result_2)} rows'\n    assert pred_query_result_1[0][0] == 'recAlAwtBZ0Fqbr5K', f'Expected event ID to match, but found {pred_query_result_1[0][0]}'\n    assert pred_query_result_2[0][0] == 'rec280Sk7o31iG0Tx', f'Expected member ID to match, but found {pred_query_result_2[0][0]}'\n    "]}
{"instance_id": "261_3", "selected_database": "student_club", "query": "I am trying to find all events that are either 'Closed' or 'Planning' and have a budget amount greater than 100. However, I want to use the IN clause with LIKE conditions to filter the event_status. My current query works but seems inefficient. Is there a way to simplify it using the SIMILAR TO clause?", "error_sql": ["SELECT * FROM budget WHERE amount > 100 AND event_status IN ('%Closed%', '%Planning%');"], "sol_sql": ["SELECT * FROM budget WHERE amount > 100 AND event_status SIMILAR TO '%(Clos|Pla)%';"], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "259_2", "selected_database": "european_football_2", "query": "I am new to functions and triggers in PostgreSQL. I am trying to create a trigger function to log changes in the player's name in the Player table. I followed a tutorial but encountered an error. The code block and the error are provided below. The Player table contains detailed information about players. The player_audits table is intended to keep track of any changes to the player's name along with the timestamp of the change.", "error_sql": ["CREATE OR REPLACE FUNCTION log_player_name_changes() RETURNS trigger AS $BODY$ BEGIN IF NEW.player_name <> OLD.player_name THEN INSERT INTO player_audits(player_id, old_player_name, changed_on) VALUES(OLD.id, OLD.player_name, now()); END IF; RETURN NEW; END; $BODY$ CREATE TRIGGER tr_change_playername AFTER UPDATE OF player_name ON player FOR EACH ROW EXECUTE PROCEDURE log_player_name_changes();"], "sol_sql": ["CREATE OR REPLACE FUNCTION log_player_name_changes() RETURNS trigger AS $BODY$ BEGIN IF NEW.player_name <> OLD.player_name THEN INSERT INTO player_audits(player_id, old_player_name, changed_on) VALUES(OLD.id, OLD.player_name, now()); END IF; RETURN NEW; END; $BODY$ LANGUAGE plpgsql;CREATE TRIGGER tr_change_playername AFTER UPDATE OF player_name ON player FOR EACH ROW EXECUTE PROCEDURE log_player_name_changes();"], "preprocess_sql": ["CREATE TABLE player_audits (player_id int, old_player_name text, changed_on timestamp );"], "clean_up_sql": ["DROP TABLE IF EXISTS player_audits;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res, _, _ = execute_queries([f\"SELECT player_name FROM player WHERE id = 1;\"], db_name,conn)\n    old_p_name = res[0][0]\n    check_sql = [f\"UPDATE player SET player_name = {old_p_name} WHERE id = 1;\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([f\"SELECT * FROM player_audits\"], db_name, conn)\n    assert len(res) == 0, f\"The trigger conditioning does not work.\"\n    \n    check_sql = [f\"UPDATE player SET player_name = 'James Higginsons' WHERE id = 1;\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([f\"SELECT old_player_name FROM player_audits LIMIT 1\"], db_name,conn)\n    old_name = res[0][0]\n    assert old_name == 'Aaron Appindangoye', f\"The trigger does not work.\"\n"]}
{"instance_id": "392_2", "selected_database": "student_club", "query": "The data in the event_attendance table looks like this:\\n| MemberID | EventID | EventType | AttendanceDate |\\n| -------- | ------- | --------- | -------------- |\\n| 1        | 101     | Game      | 2023-01-01     |\\n| 1        | 102     | Game      | 2023-01-10     |\\n| 1        | 103     | Game      | 2023-02-15     |\\n| 1        | 104     | Game      | 2023-02-20     |\\n| 1        | 105     | Workshop  | 2023-03-01     |\\n| 1        | 106     | Workshop  | 2023-03-20     |\\n| 2        | 107     | Game      | 2023-01-15     |\\n| 2        | 108     | Workshop  | 2023-02-06     |\\nWhat I am trying to build is like this:\\n| MemberID | Game_AttendanceDate | Game_Attendances | Workshop_AttendanceDate | Workshop_Attendances | Total_Attendances |\\n| -------- | ------------------- | ---------------- | ----------------------- | ---------------------- | ------------------- |\\n| 1        | 2023-02-20          | 4                | 2023-03-20              | 2                    | 6                   |\\n| 2        | 2023-01-15          | 1                | 2023-02-06              | 1                    | 2                   |\\nThe data should be one row for each member.\\nColumn definitions of the expected output:\\nGame_AttendanceDate : Latest attendance date based on date where EventType = 'Game'\\nGame_Attendances: Total number of Game events attended by each member.\\nWorkshop_AttendanceDate: Latest attendance date based on date where EventType = 'Workshop'\\nWorkshop_Attendances: Total number of Workshop events attended by each member.\\nTotal_Attendances: Total events attended by each member.\\nThe SQL Code that I have tried:\\nsql\\nselect\\n    coalesce(a.MemberID,b.MemberID) as MemberID,\\n    a.AttendanceDate as Game_AttendanceDate,\\n    Game_Attendances,\\n    b.AttendanceDate as Workshop_AttendanceDate,\\n    Workshop_Attendances,\\n    Game_Attendances + Workshop_Attendances as Total_Attendances    \\\\nfrom \\\\n(select \\\\n    MemberID, \\\\n    EventType,\\n    AttendanceDate,\\n    count(*) over(partition by MemberID,EventType) as Game_Attendances,\\n    row_number() over(partition by MemberID,EventType order by AttendanceDate desc) as RNUM\\\\nfrom event_attendance \\\\n    where EventType ='Game'\\\\n) a join (\\\\n    select \\\\n    MemberID, \\\\n    EventType,\\n    AttendanceDate,\\n    count(*) over(partition by MemberID,EventType) as Workshop_Attendances,\\n    row_number() over(partition by MemberID,EventType order by AttendanceDate desc) as RNUM\\\\nfrom event_attendance \\\\n    where EventType ='Workshop'\\\\n) b on a.MemberID = b.MemberID \\\\nwhere a.RNUM = 1 and b.RNUM = 1\\\\n\\nI have to do this calculation for another 2 categories then that will add up another 2 sub queries. Is there anyway to optimize this SQL code?", "error_sql": ["\nSELECT\n    COALESCE(a.MemberID, b.MemberID) AS MemberID,\n    a.AttendanceDate AS Latest_Game_Date,\n    a.Game_Attendance AS Total_Game_Attendance,\n    b.AttendanceDate AS Latest_Workshop_Date,\n    b.Workshop_Attendance AS Total_Workshop_Attendance,\n    a.Game_Attendance + b.Workshop_Attendance AS Total_Attendance\nFROM \n(\n    SELECT \n        MemberID, \n        EventType,\n        AttendanceDate,\n        COUNT(EventID) OVER(PARTITION BY MemberID, EventType) AS Game_Attendance,\n        ROW_NUMBER() OVER(PARTITION BY MemberID, EventType ORDER BY AttendanceDate DESC) AS RNUM\n    FROM event_attendance\n    WHERE EventType = 'Game'\n) a\nFULL JOIN \n(\n    SELECT \n        MemberID, \n        EventType,\n        AttendanceDate,\n        COUNT(EventID) OVER(PARTITION BY MemberID, EventType) AS Workshop_Attendance,\n        ROW_NUMBER() OVER(PARTITION BY MemberID, EventType ORDER BY AttendanceDate DESC) AS RNUM\n    FROM event_attendance\n    WHERE EventType = 'Workshop'\n) b\nON a.MemberID = b.MemberID\nWHERE (a.RNUM = 1 OR a.RNUM IS NULL) AND (b.RNUM = 1 OR b.RNUM IS NULL);\n\n"], "sol_sql": ["\nSELECT\n    ea.MemberID,\n    MAX(CASE WHEN ea.EventType = 'Game' THEN ea.AttendanceDate END) AS Latest_Game_Date,\n    SUM(CASE WHEN ea.EventType = 'Game' THEN 1 ELSE 0 END) AS Total_Game_Attendance,\n    MAX(CASE WHEN ea.EventType = 'Workshop' THEN ea.AttendanceDate END) AS Latest_Workshop_Date,\n    SUM(CASE WHEN ea.EventType = 'Workshop' THEN 1 ELSE 0 END) AS Total_Workshop_Attendance,\n    COUNT(*) AS Total_Attendance\nFROM (\n    SELECT MemberID, EventType, AttendanceDate\n    FROM event_attendance\n    WHERE EventType IN ('Game', 'Workshop')\n) ea\nGROUP BY ea.MemberID\nORDER BY ea.MemberID;\n\n"], "preprocess_sql": ["\nCREATE TABLE event_attendance (MemberID int, EventID int, EventType text, AttendanceDate date); INSERT INTO event_attendance (MemberID, EventID, EventType, AttendanceDate) VALUES (1, 101, 'Game', '2023-01-01'), (1, 102, 'Game', '2023-01-10'), (1, 103, 'Game', '2023-02-15'), (1, 104, 'Game', '2023-02-20'), (1, 105, 'Workshop', '2023-03-01'), (1, 106, 'Workshop', '2023-03-20'), (2, 107, 'Game', '2023-01-15'), (2, 108, 'Workshop', '2023-02-06');\n"], "clean_up_sql": ["\nDROP TABLE event_attendance;\n\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n\n    ", "\nimport datetime\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][0] == 1, f'Expected MemberID 1 in the first row, but found {pred_query_result[0][0]}'\n    pred_game_date = pred_query_result[0][1]\n    pred_game_date_str = pred_game_date.strftime('%Y-%m-%d')\n    expected_date_str = '2023-02-20'\n    assert pred_game_date_str == expected_date_str, f'Expected Game_AttendanceDate 2023-02-20 for MemberID 1, but found {pred_game_date_str}'\n    assert pred_query_result[1][4] == 1, f'Expected Workshop_Attendances 1 for MemberID 2, but found {pred_query_result[1][4]}'\n\n    assert pred_query_result[0][5] == 6, f'Expected Total_Attendances 6 for MemberID 1, but found {pred_query_result[0][5]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "], "efficiency": true}
{"instance_id": "405_3", "selected_database": "codebase_community", "query": "I have a table named \"test\" under database \"codebase_community\". My goal is to return all rows where value contains a given array. For example:['friend', 'cat'] should return rows 1 and 2.['%friend%', '%cat%'] should return rows 1, 2 and 4.Currently I'm using this command but it's not working for example 2 listed above, when (array['%friend%', '%cat%']::varchar[]).As it works for example 1, I think the problem is with the % symbols, but I don't know how to handle this, since I don't need to explicitly match the values.", "error_sql": ["\nSELECT DISTINCT id, value\nFROM test\nWHERE value @> (ARRAY['friend', 'cat']::VARCHAR[]);\n"], "sol_sql": ["\nSELECT t.id, t.value\nFROM   test t\nWHERE  NOT EXISTS (\n   SELECT FROM unnest('{%friend%, %cat%}'::text[]) AS p(pattern)\n   WHERE  NOT EXISTS (\n      SELECT FROM unnest(t.value) AS a(elem)\n      WHERE  a.elem LIKE p.pattern\n      )\n   )\n"], "preprocess_sql": ["\nCREATE TABLE test (\n    id INT PRIMARY KEY,\n    value TEXT[]\n);\n\nINSERT INTO test (id, value) VALUES\n(1, ARRAY['friend', 'apple', 'cat']),\n(2, ARRAY['cat', 'friend', 'dog']),\n(3, ARRAY['pasta', 'best-friend', 'lizard']),\n(4, ARRAY['wildcat', 'potato', 'alices-friend']);\n"], "clean_up_sql": ["DROP TABLE test;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 3, f'Expected 3 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][0] == 1, f'Expected id to be 1, but found {pred_query_result[0][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[2][1] == ['wildcat', 'potato', 'alices-friend'], f\"Expected value to be ['wildcat', 'potato', 'alices-friend'], but found {pred_query_result[2][1]}\"\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[2][0] == 4, f'Expected id to be 4, but found {pred_query_result[2][0]}'\n    "]}
{"instance_id": "510_3", "selected_database": "financial", "query": "In the financial database, there is a table named 'account_info' that stores the detailed information of accounts. Each row in the table includes an array in the 'condition' column, which contains various conditions related to the account. We need to find all qualifying accounts where the 'condition' column contains a condition with a specific 'rootcompanyid' value of 5. The current query is only returning the last row that matches the condition, but we need all rows that have this 'rootcompanyid' value in any part of the array.", "error_sql": ["SELECT *  FROM account_info WHERE ((condition->0->>'conditions')::json->>'rootcompanyid')::json->>'$in' = '[5]';"], "sol_sql": ["SELECT * FROM account_info WHERE condition::jsonb @> '[ { \"conditions\": { \"rootcompanyid\": { \"$in\": [5] } } } ]'"], "preprocess_sql": ["CREATE TABLE IF NOT EXISTS account_info (account_id INTEGER, condition JSONB);", "INSERT INTO account_info (account_id, condition) VALUES (1, '[{\"action\":\"read\",\"subject\":\"rootcompany\",\"conditions\":{\"rootcompanyid\":{\"$in\":[35,20,5,6]}}}]'::jsonb), (2, '[{\"action\":\"read\",\"subject\":\"rootcompany\",\"conditions\":{\"rootcompanyid\":{\"$in\":[1,4,2,3,6]}}}]'::jsonb), (3, '[{\"action\":\"read\",\"subject\":\"rootcompany\",\"conditions\":{\"rootcompanyid\":{\"$in\":[5]}}}]'::jsonb);"], "clean_up_sql": ["DROP TABLE IF EXISTS account_info;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} row(s).'\n    assert pred_query_result[0][0] == 1, f'Expected the account_id is 1, but found {pred_query_result[0][0]}'\n    assert pred_query_result[1][0] == 3, f'Expected the account_id is 3, but found {pred_query_result[1][0]}'"], "external_data": "{\"action\":\"read\",\"subject\":\"rootcompany\",\"conditions\":{\"rootcompanyid\":{\"$in\":[35,20,5,6]}}}, {\"action\":\"read\",\"subject\":\"rootcompany\",\"conditions\":{\"rootcompanyid\":{\"$in\":[1,4,2,3,6]}}}, {\"action\":\"read\",\"subject\":\"rootcompany\",\"conditions\":{\"rootcompanyid\":{\"$in\":[5]}}}"}
{"instance_id": "511_2", "selected_database": "superhero", "query": "I am working on a superhero database and have a table called 'hero_power' that records the powers of each superhero. Currently, the combination of 'hero_id' and 'power_id' is supposed to be unique, meaning that a superhero cannot have the same power listed more than once. However, this is not quite what I want. Instead, I would want the combination 'hero_id' and 'power_id' to be unique only in cases where the power is currently active. In other words, a superhero should be able to have multiple instances of the same power listed if the power is inactive, but should not be allowed to have duplicates that are active. Is there a way to enforce this in this table?", "error_sql": ["ALTER TABLE hero_power ADD CONSTRAINT unique_active_hero_power UNIQUE (hero_id, power_id);"], "sol_sql": ["CREATE UNIQUE INDEX idx_hero_power_active ON hero_power (hero_id, power_id) WHERE active;"], "preprocess_sql": ["ALTER TABLE hero_power ADD COLUMN active BOOLEAN DEFAULT TRUE;"], "clean_up_sql": ["ALTER TABLE hero_power DROP COLUMN IF EXISTS active;", "DROP INDEX IF EXISTS idx_hero_power_active;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    try:\n        insert_sql_1 = execute_queries(['INSERT INTO hero_power (hero_id, power_id, active) VALUES (1, 1, TRUE);'], db_name, conn)[0];\n        assert False, 'Inserting duplicate id should have raised an error'\n    except Exception as err:\n        assert 'duplicate' in str(err), f'Expected duplicate key error, but found {err}.'\n    check_insertion_result_1 = execute_queries(['SELECT COUNT(*) FROM hero_power WHERE hero_id = 1 AND power_id = 1;'], db_name, conn)[0];\n    assert check_insertion_result_1[0][0] == 1, 'Expected only 1 entry for hero_id 1 and power_id 1.'\n    insert_sql_2 = execute_queries(['INSERT INTO hero_power (hero_id, power_id, active) VALUES (1, 1, FALSE);'], db_name, conn)[0];\n    check_insertion_result_2 = execute_queries(['SELECT COUNT(*) FROM hero_power WHERE hero_id = 1 AND power_id = 1;'], db_name, conn)[0];\n    assert check_insertion_result_2[0][0] == 2, 'Expected two entries for hero_id 1 and power_id 1, one active and one inactive.'\n    insert_sql_3 = execute_queries(['INSERT INTO hero_power (hero_id, power_id, active) VALUES (1, 1, FALSE);'], db_name, conn)[0];\n    check_insertion_result_3 = execute_queries(['SELECT COUNT(*) FROM hero_power WHERE hero_id = 1 AND power_id = 1;'], db_name, conn)[0];\n    assert check_insertion_result_3[0][0] == 3, 'Expected three entries for hero_id 1 and power_id 1, one active and two inactive.'"]}
{"instance_id": "513_3", "selected_database": "toxicology", "query": "In the toxicology database, we have a table named `orders` that records the purchases made by users. Each record includes the `user_id`, `email`, `segment` (type of purchase), `destination` (location of purchase), and `revenue` (amount spent). We need to identify users who meet specific criteria based on their purchase history:\\n1) Users who have made a purchase in the `luxury` segment with a `destination` of `New York`.\\n2) Users who have made a purchase in the `luxury` segment with a `destination` of `London`.\\n3) Users who have made purchases in the `basic` segment with a `destination` of `New York` and the total revenue from these purchases exceeds $2,000.\\n4) Users who have never made a purchase with a `destination` of `Miami`.\\nGiven the sample data, we expect to retrieve the following users:\\nuser_id     email \\\\(3           mike@me.com \\\\(4           sally@you.com \\\\(5           bob@gmail.com \\\\)The user attempted to use the following SQL query to get part of the required results, but it did not account for conditions 3 and 4:\\nsql \\\\(SELECT DISTINCT(user_id), email FROM orders o WHERE (o.segment = 'luxury' AND o.destination = 'New York') OR (o.segment = 'luxury' AND o.destination = 'London') \\\\)", "error_sql": ["SELECT DISTINCT(user_id), email FROM orders o WHERE (o.segment = 'luxury' AND o.destination = 'New York') OR (o.segment = 'luxury' AND o.destination = 'London')"], "sol_sql": ["SELECT DISTINCT o1.user_id, o1.email FROM orders o1 WHERE (o1.segment = 'luxury' AND o1.destination = 'New York') OR (o1.segment = 'luxury' AND o1.destination = 'London') OR (o1.segment = 'basic' AND o1.destination = 'New York' AND o1.user_id IN (SELECT o2.user_id FROM orders o2 WHERE o2.segment = 'basic' AND o2.destination = 'New York' GROUP BY o2.user_id HAVING SUM(o2.revenue) > 2000)) EXCEPT SELECT DISTINCT o3.user_id, o3.email FROM orders o3 WHERE o3.destination = 'Miami'"], "preprocess_sql": ["CREATE TABLE orders (user_id INT, email TEXT, segment TEXT, destination TEXT, revenue NUMERIC); INSERT INTO orders (user_id, email, segment, destination, revenue) VALUES (1, 'joe@smith.com', 'basic', 'New York', 500), (1, 'joe@smith.com', 'luxury', 'London', 750), (1, 'joe@smith.com', 'luxury', 'London', 500), (1, 'joe@smith.com', 'basic', 'New York', 625), (1, 'joe@smith.com', 'basic', 'Miami', 925), (1, 'joe@smith.com', 'basic', 'Los Angeles', 218), (1, 'joe@smith.com', 'basic', 'Sydney', 200), (2, 'mary@jones.com', 'basic', 'Chicago', 375), (2, 'mary@jones.com', 'luxury', 'New York', 1500), (2, 'mary@jones.com', 'basic', 'Toronto', 2800), (2, 'mary@jones.com', 'basic', 'Miami', 750), (2, 'mary@jones.com', 'basic', 'New York', 500), (2, 'mary@jones.com', 'basic', 'New York', 625), (3, 'mike@me.com', 'luxury', 'New York', 650), (3, 'mike@me.com', 'basic', 'New York', 875), (4, 'sally@you.com', 'luxury', 'Chicago', 1300), (4, 'sally@you.com', 'basic', 'New York', 1200), (4, 'sally@you.com', 'basic', 'New York', 1000), (4, 'sally@you.com', 'luxury', 'Sydney', 725), (5, 'bob@gmail.com', 'basic', 'London', 500), (5, 'bob@gmail.com', 'luxury', 'London', 750);"], "clean_up_sql": ["DROP TABLE orders;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "512_1", "selected_database": "formula_1", "query": "In the Formula 1 database, there is a table named 'cars' which contains the information of cars. Each entry includes a 'version' column that records the version of the car used by the driver in the race. The version numbers are in a format similar to '3.0.5-1-test-dev' and need to be sorted correctly to determine the latest version used in a race. However, the current sorting method does not handle multi-digit numbers correctly and fails when the version includes additional string information after the numeric version. The task is to write a query that correctly sorts the versions. If the table is sorted, I can get the latest version by select the first one.", "error_sql": ["SELECT version FROM cars ORDER BY SUBSTRING(version, '^[0-9]+') DESC, SUBSTRING(version, '[0-9]+\\.[0-9]+\\.([0-9]+)-') DESC, CAST(SUBSTRING(version, '[0-9]+\\.[0-9]+\\.[0-9]+-([0-9]+)') AS INTEGER) DESC, SUBSTRING(version, '[0-9]+\\.[0-9]+\\.[0-9]+-[0-9]+\\.([0-9]+)') DESC"], "sol_sql": ["SELECT version FROM cars ORDER BY CAST(SUBSTRING(version FROM '^[0-9]+') AS INTEGER) DESC, CAST(SUBSTRING(version FROM '[0-9]+\\.[0-9]+\\.([0-9]+)') AS INTEGER) DESC, CAST(SUBSTRING(version FROM '[0-9]+\\.[0-9]+\\.[0-9]+-([0-9]+)') AS INTEGER) DESC, CASE WHEN version LIKE '%-%' THEN SUBSTRING(version FROM '-(.*)') ELSE '' END DESC;"], "preprocess_sql": ["CREATE TABLE cars (version varchar(100))", "INSERT INTO cars (version) VALUES ('3.0.5-1-test-dev'), ('3.0.6-1'), ('3.0.7-1-test'), ('3.0.8-1-test-dev-test23'), ('3.0.9-1'), ('3.0.13-2'), ('3.0.4-1-1'), ('3.0.10-1'), ('3.0.11-2'), ('3.0.11-1')"], "clean_up_sql": ["DROP TABLE cars;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "514_3", "selected_database": "thrombosis_prediction", "query": "In the thrombosis_prediction database, we have a set of normalized tables representing patients, medications, and their prescriptions. Each patient can be prescribed multiple medications, and each medication can be prescribed to multiple patients. For reporting purposes, we need a highly denormalized view that shows each patient's name and a list of all medications they are prescribed. However, when we filter the list to show only patients who are prescribed a specific medication (e.g., Aspirin), we lose the information about other medications those patients are prescribed. We want to filter by a specific medication but still get a list of all medications that a patient is prescribed in one row.", "error_sql": ["SELECT prescriptions.patient_id, array_agg(DISTINCT prescriptions.medication_id ORDER BY prescriptions.medication_id) AS medications FROM prescriptions INNER JOIN prescriptions AS Aspirin_filter ON prescriptions.patient_id = Aspirin_filter.patient_id AND Aspirin_filter.medication_id = 1 GROUP BY prescriptions.patient_id;"], "sol_sql": ["WITH select_patient AS ( SELECT patient_id FROM prescriptions WHERE medication_id = 1 ) SELECT patient_id, array_agg(DISTINCT medication_id ORDER BY medication_id) AS medications FROM prescriptions WHERE patient_id in (select patient_id from select_patient) GROUP BY patient_id;"], "preprocess_sql": ["CREATE TABLE patients ( patient_id SERIAL PRIMARY KEY, patient_name TEXT NOT NULL );", "CREATE TABLE medications ( medication_id SERIAL PRIMARY KEY, medication_name TEXT NOT NULL );", "CREATE TABLE prescriptions ( patient_id INT REFERENCES patients (patient_id), medication_id INT REFERENCES medications (medication_id), PRIMARY KEY (patient_id, medication_id) );", "INSERT INTO patients (patient_name) VALUES ('Alice'), ('Bob'), ('Charlie');", "INSERT INTO medications (medication_name) VALUES ('Aspirin'), ('Ibuprofen'), ('Paracetamol'), ('Warfarin');", "INSERT INTO prescriptions (patient_id, medication_id) VALUES (1, 1), (1, 2), (1, 3);", "INSERT INTO prescriptions (patient_id, medication_id) VALUES (2, 2);", "INSERT INTO prescriptions (patient_id, medication_id) VALUES (3, 2), (3, 1), (3, 3), (3, 4);"], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "], "efficiency": true}
{"instance_id": "491_1", "selected_database": "formula_1", "query": "In the context of Formula 1 racing data, I have two tables: `races` and `results`. The `races` table contains information about each race, including the `raceId` which uniquely identifies each race. The `results` table contains detailed information about the results of each race, including the `raceId` to link back to the `races` table, `driverId` to identify the driver, and `points` which represent the points scored by the driver in that race. I need to calculate the total points scored by each driver across all races, but only for races where the driver has participated. If a driver has not participated in any races, their total points should be `0`. I attempted to write a query to achieve this but encountered issues with grouping and ensuring that drivers who haven't participated in any races are included with a total of `0` points.", "error_sql": ["SELECT r.driverId, ((SELECT COALESCE(SUM(r.points), 0) FROM results r WHERE r.raceId = races.raceId) - (SELECT COALESCE(SUM(r.points), 0) FROM results r WHERE r.raceId = races.raceId)) AS total_points FROM results r GROUP BY r.driverId"], "sol_sql": ["SELECT d.driverId, COALESCE(SUM(r.points), 0) AS total_points FROM drivers d LEFT JOIN results r ON d.driverId = r.driverId GROUP BY d.driverId"], "preprocess_sql": "", "clean_up_sql": "", "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "492_1", "selected_database": "superhero", "query": "In the context of the superhero database, I need to calculate the total count of superheroes by their alignment and also display the count of superheroes for each specific alignment and race combination. I attempted to write a query to achieve this but it doesn't provide the total count by alignment as I expected. Here's what I tried:", "error_sql": ["select count(S.id), A.alignment, count(R.race), R.race from superhero S, alignment A, race R where S.alignment_id=A.id and S.race_id=R.id group by A.alignment, R.race;"], "sol_sql": ["SELECT \n    sqA.alignment_count     AS total_by_alignment,\n    A.alignment             AS alignment,\n    R.race                  AS race,\n    sqAR.alignment_race_count AS count_by_alignment_race\nFROM\n    (\n       SELECT\n           alignment_id,\n           COUNT(*) AS alignment_count\n       FROM superhero\n       GROUP BY alignment_id\n    ) sqA\n\n    INNER JOIN\n    (\n       SELECT\n           alignment_id,\n           race_id,\n           COUNT(*) AS alignment_race_count\n       FROM superhero\n       GROUP BY alignment_id, race_id\n    ) sqAR ON sqA.alignment_id = sqAR.alignment_id\n\n    INNER JOIN alignment A ON sqA.alignment_id = A.id\n\n    INNER JOIN race R ON sqAR.race_id = R.id\nORDER BY\n    A.alignment,\n    R.race;"], "preprocess_sql": "", "clean_up_sql": "", "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "490_1", "selected_database": "formula_1", "query": "In the context of analyzing Formula 1 race results, I'm trying to understand the behavior of window functions in PostgreSQL. Specifically, I'm looking at the `array_agg` function with and without an `ORDER BY` clause within a window function. I expect both to return the same result since no filtering is applied, but they don't. Here's the scenario: I have a table of race results, and I want to aggregate the driver IDs in two ways: one with an order by the points they scored in the race, and another without any order. The results seem to suggest that ordering the partition affects the aggregation, which is confusing. Here's the SQL I used:", "error_sql": ["select driverId, points, lead(driverId) over (order by points asc) as \"lead(driverId) with order\", array_agg(driverId) over (order by points asc) as \"array_agg(driverId) with order\", lead(driverId) over () as \"lead(driverId) without order\", array_agg(driverId) over () as \"array_agg(driverId) without order\" from results where raceId = 19 order by driverId asc"], "sol_sql": ["select driverId, points, array_agg(driverId) over (order by points asc) as \"array_agg(driverId) with order\", array_agg(driverId) over () as \"array_agg(driverId) without order\" from results where raceId = 19 order by driverId asc"], "preprocess_sql": "", "clean_up_sql": "", "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred = execute_queries(pred_sqls,db_name,conn)\n    sol = execute_queries(sol_sqls,db_name,conn)\n    assert pred == sol\n    return pred == sol"]}
{"instance_id": "493_1", "selected_database": "formula_1", "query": "In the context of Formula 1 racing data analysis, a user is attempting to calculate the total duration of pit stops for each race day based on the difference between consecutive pit stop times recorded in the same column. The user has a table that records pit stop details including race ID, driver ID, stop number, lap number, pit stop time, and duration. The user's initial approach was to calculate the maximum and minimum pit stop times for each race day and then find the difference between these times to estimate the total pit stop duration. However, this approach misses the intermediate pit stops, leading to an inaccurate total duration calculation. The user is seeking a method to accurately calculate the total pit stop duration by considering all consecutive pit stop times for each race day.", "error_sql": ["SELECT \n  raceId,\n  MAX(time::time) AS end_time,\n  MIN(time::time) AS start_time,\n  (MAX(time::time) - MIN(time::time)) AS total_duration\nFROM pitStops\nWHERE raceId = 842\nGROUP BY raceId;"], "sol_sql": ["WITH cte AS (\n    SELECT\n        p.*,\n        CEIL( (ROW_NUMBER() OVER (\n                 PARTITION BY raceId \n                 ORDER BY time::time\n               ) + 1 ) / 2.0\n        ) AS rn\n    FROM pitStops p\n    WHERE raceId = 842\n),\ncte2 AS (\n    SELECT\n        rn,\n        MIN(time::time) AS starttime,\n        MAX(time::time) AS endtime,\n        CAST(MAX(time::time) - MIN(time::time) AS time) AS total_pause\n    FROM cte\n    GROUP BY rn\n)\nSELECT\n    MAX(endtime) AS endtime,\n    MIN(starttime) AS starttime,\n    CAST(SUM(total_pause) AS time) AS total_pit_stop_duration\nFROM cte2;"], "preprocess_sql": "", "clean_up_sql": "", "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "494_1", "selected_database": "toxicology", "query": "In the toxicology database, I'm attempting to retrieve a specific data structure from a query. My data is structured in a way that each molecule has atoms connected by bonds, and each molecule is labeled as either carcinogenic (+) or not carcinogenic (-). I want to return a  object that groups molecules by their label and lists the atoms and bonds for each molecule. The desired output format is a  object where each key is a label, and the value is an array of objects, each representing a molecule with its atoms and bonds. Here's the SQL query I have so far, but it doesn't produce the desired output structure:", "error_sql": ["select label, JSON_AGG(JSON_BUILD_OBJECT(atom.molecule_id, atom.atom_id)) AS groupedMolecules FROM molecule JOIN atom ON molecule.molecule_id = atom.molecule_id GROUP BY label"], "sol_sql": ["SELECT json_object_agg(label, groupedMolecules) AS molecules_by_label\nFROM (\n  SELECT label,\n         json_agg(\n           json_build_object(\n             'molecule_id', molecule.molecule_id,\n             'atoms', (\n               SELECT json_agg(\n                 json_build_object(\n                   'atom_id', atom.atom_id,\n                   'element', atom.element\n                 )\n               )\n               FROM atom\n               WHERE atom.molecule_id = molecule.molecule_id\n             ),\n             'bonds', (\n               SELECT json_agg(\n                 json_build_object(\n                   'bond_id', bond.bond_id,\n                   'bond_type', bond.bond_type\n                 )\n               )\n               FROM bond\n               WHERE bond.molecule_id = molecule.molecule_id\n             )\n           )\n         ) AS groupedMolecules\n  FROM molecule\n  GROUP BY label\n) AS sub;"], "preprocess_sql": "", "clean_up_sql": "", "test_cases": ["import json\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    def json_matches_gold(generated_json, gold_json):\n        # If either object is a string, parse it as JSON\n        if isinstance(generated_json, str):\n            generated_json = json.loads(generated_json)\n        if isinstance(gold_json, str):\n            gold_json = json.loads(gold_json)\n\n        # Return whether the Python structures match exactly\n        return generated_json == gold_json\n    \n    sol = execute_queries(sol_sqls,db_name,conn)\n    pred = execute_queries(pred_sqls,db_name,conn)\n    assert json_matches_gold(sol[0], pred[0])\n    return json_matches_gold(sol[0], pred[0])"]}
{"instance_id": "497_2", "selected_database": "toxicology", "query": "In the context of a toxicology database, I have a `molecule` table that tracks molecules and their carcinogenic status, and an `atom` table that records atoms within these molecules. Each atom is identified by a unique `atom_id` and belongs to a molecule identified by `molecule_id`. The `element` column in the `atom` table specifies the chemical element of the atom. I need to count the number of sodium (`na`) and carbon (`c`) or chlorine (`cl`) atoms for each molecule. However, if both carbon (`c`) and chlorine (`cl`) elements within the same molecule, they should be counted as one. Here's the SQL query I attempted, but it counts each atom individually, even if they are of the same element within the same molecule:", "error_sql": ["SELECT molecule_id, COALESCE(SUM(CASE WHEN element = 'na' THEN 1 ELSE 0 END), 0) na_atoms, COALESCE(SUM(CASE WHEN element = 'c' OR element = 'cl' THEN 1 ELSE 0 END), 0) c_atoms FROM atom GROUP BY molecule_id;"], "sol_sql": ["SELECT\n    molecule_id,\n    COUNT(DISTINCT CASE WHEN element = 'na' THEN 1 END)         AS na_atoms,\n    COUNT(DISTINCT CASE WHEN element IN ('c', 'cl') THEN molecule_id END) AS c_atoms\nFROM atom\nGROUP BY molecule_id;"], "preprocess_sql": "", "clean_up_sql": "", "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "499_1", "selected_database": "european_football_2", "query": "In the context of analyzing football match data, I'm attempting to calculate the average number of goals scored by each team, grouped by the hour of the match. The goal is to understand the performance trends of teams at different times of the day without resorting to external scripting. Here's the initial approach I took, which unfortunately resulted in an error due to incorrect handling of the timestamp data.", "error_sql": ["SELECT home_team_api_id, AVG(home_team_goal) as avg_home_goals, AVG(away_team_goal) as avg_away_goals, SUM(home_team_goal) as total_home_goals, SUM(away_team_goal) as total_away_goals, MAX(home_team_goal) as max_home_goals, MIN(home_team_goal) as min_home_goals, COUNT(home_team_api_id) as count FROM Match GROUP BY home_team_api_id, date_part('hour', date);"], "sol_sql": ["SELECT date_trunc('hour', \"date\"::timestamp), home_team_api_id, AVG(home_team_goal) as avg_home_goals, AVG(away_team_goal) as avg_away_goals, SUM(home_team_goal) as total_home_goals, SUM(away_team_goal) as total_away_goals, MAX(home_team_goal) as max_home_goals, MIN(home_team_goal) as min_home_goals, COUNT(home_team_api_id) as count FROM Match GROUP BY date_trunc('hour', \"date\"::timestamp), home_team_api_id;"], "preprocess_sql": "", "clean_up_sql": "", "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "238_1", "selected_database": "debit_card_specializing", "query": "In the table clients_to_groups, we need to identify clients who have made transactions at gas stations that belong to specific groups. Specifically, we want to find clients who have made transactions at gas stations that are either in the group 1 or 3 AND also in group 5 or 6. For example, a client who has made transactions at a gas station in the group 5 and another transaction at a gas station in the group 1 should be included in the results, but a client who has only made transactions at gas stations in the group 5 should not be included.", "error_sql": ["SELECT DISTINCT c.id FROM clients c INNER JOIN clients_to_groups at1 ON c.id = at1.client_id INNER JOIN clients_to_groups at2 ON c.id = at2.client_id WHERE at1.group_id IN (5, 6) AND at2.group_id IN (1, 3);"], "sol_sql": ["SELECT c.id  FROM clients c INNER JOIN clients_to_groups ctg ON c.id = ctg.client_id AND ctg.group_id IN (1,3,5,6) GROUP BY c.id HAVING  COUNT(CASE WHEN ctg.group_id IN (1,3) THEN 1 END) > 0 AND COUNT(CASE WHEN ctg.group_id IN (5,6) THEN 1 END) > 0;"], "preprocess_sql": ["CREATE TABLE clients (id INT NOT NULL);", "CREATE TABLE groups (id INT NOT NULL);", "CREATE TABLE clients_to_groups (id serial, group_id INT, client_id INT);", "INSERT INTO clients(id) VALUES (0), (1), (2), (3);", "INSERT INTO groups(id) VALUES (1), (3), (5), (6);", "INSERT INTO clients_to_groups(client_id, group_id) VALUES (0, 1), (0, 5), (1, 1), (1, 90), (2, 1), (3, 3), (3, 5), (3, 90);", "INSERT INTO clients (id) SELECT random() from generate_series(1,2000);", "INSERT INTO clients_to_groups(client_id, group_id) SELECT random(), random() from generate_series(1,2000);"], "clean_up_sql": ["DROP TABLE clients;", "DROP TABLE groups;", "DROP TABLE clients_to_groups;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "], "efficiency": true}
{"instance_id": "517_2", "selected_database": "european_football_2", "query": "In the context of the 'european_football_2' database, consider a table that records daily financial transactions for football clubs. Each transaction includes the date, the club name, and the amount of money involved, which can be positive (income) or negative (expense). The goal is to group these transactions by club and sign (positive or negative) and sum the amounts for consecutive transactions of the same sign for each club. For example, if a club has consecutive positive transactions, they should be summed up into a single transaction. The user attempted to use window functions but encountered issues with their query, which did not produce the desired output.", "error_sql": ["SELECT transaction_date AS date, club_name, sum(amount) over (partition by club_name, sign(amount) order by transaction_date) from club_transactions"], "sol_sql": ["SELECT MIN(transaction_date) AS date, club_name, SUM(amount) AS amount FROM (SELECT *, SUM(flag) OVER (PARTITION BY club_name ORDER BY transaction_date) AS grp FROM (SELECT *, COALESCE(SIGN(amount) <> LAG(SIGN(amount)) OVER (PARTITION BY club_name ORDER BY transaction_date), true)::int AS flag FROM club_transactions) t) t GROUP BY club_name, grp ORDER BY club_name, date;"], "preprocess_sql": ["CREATE TABLE club_transactions (transaction_date DATE, club_name VARCHAR(50), amount INTEGER);", "INSERT INTO club_transactions (transaction_date, club_name, amount) VALUES ('2023-01-01', 'Manchester United', 3), ('2023-01-02', 'Manchester United', 2), ('2023-01-03', 'Manchester United', 1), ('2023-01-04', 'Manchester United', -5), ('2023-01-05', 'Manchester United', 1), ('2023-01-01', 'Liverpool', 2), ('2023-01-02', 'Liverpool', -1), ('2023-01-03', 'Liverpool', -6);"], "clean_up_sql": ["DROP TABLE club_transactions;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "519_1", "selected_database": "california_schools", "query": "I have a table in Postgres that returns flat data. But I would like it to be returned to me in a Json ordered with its children as follows, and I have not been able to solve it.Is there a way in postgresql to order the parent modules with their child modules, I attach an example \"[{\"children\":[{\"id_module\":4,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":1},{\"id_module\":3,\"desc_module\":\"C\",\"module_code\":\"232\",\"name_module\":\"C\",\"id_parent_module\":1},{\"id_module\":2,\"desc_module\":\"B\",\"module_code\":\"011.002\",\"name_module\":\"B\",\"id_parent_module\":1}],\"id_module\":1,\"desc_module\":\"A\",\"module_code\":\"001\",\"name_module\":\"A\",\"id_parent_module\":null},{\"children\":[{\"id_module\":14,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":5}],\"id_module\":5,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":null},{\"children\":[{\"id_module\":22,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":6},{\"id_module\":8,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":6},{\"id_module\":7,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":6}],\"id_module\":6,\"desc_module\":\"qw\",\"module_code\":\"23\",\"name_module\":\"asdf\",\"id_parent_module\":null},{\"children\":[{\"id_module\":21,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":9},{\"id_module\":20,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":9}],\"id_module\":9,\"desc_module\":\"asdfsad\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":null},{\"children\":[{\"id_module\":13,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":10},{\"id_module\":12,\"desc_module\":\"asdfsf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":10},{\"id_module\":11,\"desc_module\":\"asdf\",\"module_code\":\"sadf\",\"name_module\":\"asdf\",\"id_parent_module\":10}],\"id_module\":10,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":null}]\"", "error_sql": "SELECT array_to_json(array_agg(row_to_json(alias))) FROM (select * from modules ) alias", "sol_sql": ["WITH RECURSIVE cte(id, p, js) AS (SELECT t.id_module, t.id_parent_module, json_agg(t.jsn) FROM (SELECT m.id_module, m.id_parent_module, json_build_object('id_module', m1.id_module, 'id_parent_module', m1.id_parent_module, 'module_code', m1.module_code, 'name_module', m1.name_module, 'desc_module', m1.desc_module) jsn FROM modules m JOIN modules m1 ON m1.id_parent_module = m.id_module WHERE NOT EXISTS (SELECT 1 FROM modules m2 WHERE m2.id_parent_module = m1.id_module)) t GROUP BY t.id_module, t.id_parent_module UNION ALL SELECT t.id_module, t.id_parent_module, json_agg(t.jsn) FROM (SELECT m.id_module, m.id_parent_module, json_build_object('id_module', m2.id_module, 'id_parent_module', m2.id_parent_module, 'module_code', m2.module_code, 'name_module', m2.name_module, 'desc_module', m2.desc_module, 'children', c.js) jsn FROM modules m JOIN cte c ON m.id_module = c.p JOIN modules m2 ON m2.id_module = c.id) t GROUP BY t.id_module, t.id_parent_module) SELECT jsonb_pretty(t.result::jsonb) FROM (SELECT json_agg(json_build_object('id_module', m2.id_module, 'id_parent_module', m2.id_parent_module, 'module_code', m2.module_code, 'name_module', m2.name_module, 'desc_module', m2.desc_module, 'children', c.js)) result FROM cte c JOIN modules m2 ON c.id = m2.id_module WHERE c.p IS NULL) t"], "preprocess_sql": ["create table modules (id_module int, id_parent_module int, module_code text, name_module text, desc_module text);", "insert into modules values (1, null, '001', 'A', 'A'), (2, 1, '011.002', 'B', 'B'), (3, 1, '232', 'C', 'C'), (4, 1, 'asdf', 'asdf', 'asdf'), (5, null, 'asdf', 'asdf', 'asdf'), (14, 5, 'asdf', 'asdf', 'asdf'), (6, null, '23', 'asdf', 'qw'), (7, 6, 'asdf', 'asdf', 'asdf'), (8, 6, 'asdf', 'asdf', 'asdf'), (22, 6, 'asdf', 'asdf', 'asdf'), (9, null, 'asdf', 'asdf', 'asdfsad'), (20, 9, 'asdf', 'asdf', 'asdf'), (21, 9, 'asdf', 'asdf', 'asdf'), (10, null, 'asdf', 'asdf', 'asdf'), (11, 10, 'sadf', 'asdf', 'asdf'), (12, 10, 'asdf', 'asdf', 'asdfsf'), (13, 10, 'asdf', 'asdf', 'asdf');"], "clean_up_sql": ["DROP TABLE modules;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'student_club', conn)\n    sol_sqls_result = execute_queries(sol_sqls, 'student_club', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "495_1", "selected_database": "toxicology", "query": "In the context of a toxicology database, a user is trying to query molecules based on specific criteria related to their atoms and bonds. The user's query aims to find molecules that contain certain elements and bond types, with additional constraints on the molecule's label indicating carcinogenicity. The query is complex, involving multiple conditions across different tables, and the user is experiencing slow query performance, seeking to optimize it for faster execution.", "error_sql": ["SELECT DISTINCT m.molecule_id, m.label FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id JOIN bond b ON m.molecule_id = b.molecule_id WHERE (a.element LIKE '%cl%' OR a.element LIKE '%c%') AND (b.bond_type = '-' OR b.bond_type = '=') AND m.label = '+' ORDER BY m.molecule_id DESC LIMIT 5 OFFSET 0;"], "sol_sql": ["SELECT DISTINCT m.molecule_id, m.label FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id JOIN bond b ON m.molecule_id = b.molecule_id WHERE (a.element = 'cl' OR a.element = 'c') AND (b.bond_type = '-' OR b.bond_type = '=') AND m.label = '+' ORDER BY m.molecule_id DESC LIMIT 5 OFFSET 0;"], "preprocess_sql": ["CREATE EXTENSION IF NOT EXISTS pg_trgm;"], "clean_up_sql": ["DROP INDEX IF EXISTS idx_cards_search;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result"], "efficiency": true}
{"instance_id": "496_3", "selected_database": "toxicology", "query": "In the toxicology database, we have a table named 'atom_edits' that records updates to the 'atom' table. Users can update the 'element' or 'molecule_id' of an atom. If a field is not updated, it retains a NULL value. Here's an example of four edits touching two separate atoms. Atom with ID 'TR000_1' received two updates: the first one is updating the 'element' field, the second one touches the 'molecule_id'. Atom with ID 'TR000_2' received one update that changes the 'element'. We need to merge this table such that in the resulting table there's one row per atom, giving the cumulative edits.", "error_sql": ["SELECT atom_id, (ARRAY_REMOVE(ARRAY_AGG(element ORDER BY edit_id DESC), NULL))[1] AS element, (ARRAY_REMOVE(ARRAY_AGG(molecule_id ORDER BY edit_id DESC), NULL))[1] AS molecule_id FROM atom_edits GROUP BY atom_id;"], "sol_sql": ["SELECT atom_id,(ARRAY_AGG(element ORDER BY edit_id DESC) FILTER (WHERE element IS NOT NULL))[1] AS element,(ARRAY_AGG(molecule_id ORDER BY edit_id DESC)FILTER (WHERE molecule_id IS NOT NULL))[1] AS molecule_id FROM atom_edits GROUP BY atom_id"], "preprocess_sql": ["CREATE TABLE atom_edits (edit_id SERIAL PRIMARY KEY, atom_id TEXT, element TEXT, molecule_id TEXT); INSERT INTO atom_edits (atom_id, element, molecule_id) VALUES ('TR000_1', 'cl', NULL), ('TR000_1', NULL, 'TR001'), ('TR000_2', 'c', NULL);"], "clean_up_sql": ["DROP TABLE atom_edits;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result"], "efficiency": true}
{"instance_id": "354_1", "selected_database": "debit_card_specializing", "query": "We are trying to bulk insert a large number of customer records into the `customers` table using an `INSERT` statement with an `ON CONFLICT` clause. The goal is to get the `CustomerID` back for all rows, whether they are already existing or not. The `customers` table has a composite unique constraint on `Segment` and `Currency`. We are encountering an error when trying to run the SQL through Django's cursor. The error message indicates that the `ON CONFLICT DO UPDATE` command cannot affect a row a second time due to duplicate constrained values in the `VALUES` list. We need to handle this situation to ensure that we can insert new records and retrieve the IDs of both new and existing records.", "error_sql": ["INSERT INTO customers (customerid, segment, currency) VALUES (3, 'SME', 'EUR'), (1, 'KAM', 'CZK'), (3, 'SME', 'EUR') ON CONFLICT (customerid, segment, currency) DO UPDATE SET Currency = customers.Currency RETURNING CustomerID;"], "sol_sql": ["INSERT INTO customers (customerid, segment, currency)\nSELECT DISTINCT ON (customerid, segment, currency) \n       customerid, \n       segment, \n       currency\nFROM (\n    VALUES\n       (3, 'SME', 'EUR'),\n       (1, 'KAM', 'CZK'),\n       (3, 'SME', 'EUR')\n) AS v(customerid, segment, currency)\nON CONFLICT (customerid, segment, currency)\nDO UPDATE \n   SET currency = customers.currency\nRETURNING CustomerID"], "preprocess_sql": ["ALTER TABLE customers\nADD CONSTRAINT customers_customerid_segment_currency_uk\nUNIQUE (customerid, segment, currency);"], "clean_up_sql": ["DROP TABLE customers;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name,conn)[0] \n    assert test_pred_query_result_1 == [(1,), (3,)]"]}
{"instance_id": "355_1", "selected_database": "financial", "query": "In the financial database, there are two tables: 'client' and 'disp'. The 'disp' table contains a B column named 'addresses' which stores address information for each client. I attempted to join the 'client' and 'disp' tables on the 'client_id' field and then use b_array_elements to extract address details. However, I encountered an error 'cannot extract elements from a scalar' because some entries in the 'addresses' column are not arrays. I need to handle these cases properly to extract the 'PostCode' from the addresses B column for a specific client with client_id = 12345.", "error_sql": ["SELECT \n    client.client_id, \n    client.gender, \n    disp.disp_id, \n    address ->> 'PostCode' AS PostCode\nFROM client\nFULL JOIN disp ON (client.client_id = disp.client_id),\njsonb_array_elements(disp.addresses) AS address\nWHERE disp.client_id = 12345;"], "sol_sql": ["\nUPDATE disp\nSET addresses = '[{\"PostCode\": null}]'\nWHERE jsonb_typeof(addresses) <> 'array'\n   OR addresses = '[]';\n\nSELECT \n    c.client_id, \n    c.gender, \n    d.disp_id, \n    addr ->> 'PostCode' AS PostCode\nFROM client c\nFULL JOIN disp d ON c.client_id = d.client_id,\njsonb_array_elements(d.addresses) AS addr\nWHERE c.client_id = 12345;"], "preprocess_sql": ["ALTER TABLE disp \nADD COLUMN addresses jsonb;", "INSERT INTO disp (disp_id, client_id, account_id, addresses) VALUES\n    (324124, 32323432, 4342443141, '[{\"PostCode\":\"12345\"}]'),\n    (43244241, 3455566, 645634, '[null]'),\n    (42342436, 12345, 5346574, 'null');"], "clean_up_sql": ["\n    DELETE FROM disp \n    WHERE disp_id IN (324124, 43244241, 42342436);\n    ", "\n    ALTER TABLE disp \n    DROP COLUMN addresses;\n    "], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name,conn)[0] \n    assert test_pred_query_result_1 == []"]}
{"instance_id": "357_1", "selected_database": "financial", "query": "In the financial database, I want to update the 'amount' in the 'loan' table for a specific 'account_id' and 'date' if it exists, or insert a new record if it does not. However, I do not want the 'loan_id' to increment if an update occurs because it is an auto-incrementing SERIAL column. The 'loan_id' should only increment when a new record is inserted to maintain a sequential order without gaps.", "error_sql": ["\nINSERT INTO loan (\n    loan_id, \n    account_id, \n    date, \n    amount, \n    duration, \n    payments, \n    status\n)\nVALUES (\n    DEFAULT, \n    2, \n    '1996-04-29', \n    30276, \n    12, \n    2523.0, \n    'B'\n)\nON CONFLICT (loan_id, account_id, date)\nDO UPDATE\n    SET amount = loan.amount + 1000;"], "sol_sql": ["-- Correct / Solution SQL\nINSERT INTO loan (\n  account_id,\n  date,\n  amount,\n  duration,\n  payments,\n  status\n)\nVALUES (\n  2,\n  '1996-04-29',\n  30276,\n  12,\n  2523.0,\n  'B'\n)\nON CONFLICT (account_id, date)\nDO UPDATE\n   SET amount = EXCLUDED.amount + 1000;"], "preprocess_sql": ["CREATE TABLE IF NOT EXISTS loan (loan_id SERIAL PRIMARY KEY, account_id int NOT NULL, date date NOT NULL, amount int NOT NULL, duration int NOT NULL, payments double NOT NULL, status text NOT NULL, UNIQUE(account_id, date)); INSERT INTO loan (loan_id, account_id, date, amount, duration, payments, status) VALUES (134411, 2, '1994-01-05', 80952, 24, 3373.0, 'A');", "\n    DELETE FROM loan t1\n    USING loan t2\n    WHERE t1.account_id = t2.account_id\n      AND t1.date = t2.date\n      AND t1.loan_id > t2.loan_id;\n    ", "ALTER TABLE loan\n    ADD CONSTRAINT loan_accountid_date_uk\n    UNIQUE (account_id, date);"], "clean_up_sql": ["DROP TABLE IF EXISTS loan;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    \"\"\"\n    This function tests whether the given pred_sqls can fulfill the requirement:\n      \"The 'loan_id' should only increment when a new record is inserted.\"\n    Specifically, if (account_id, date) already exists, we expect to UPDATE instead\n    of inserting a new row or incrementing the loan_id.\n    \n    - We create a fresh 'loan' table with a unique constraint on (account_id, date).\n    - Insert one baseline record that matches the sol_sqls initial amount (30276).\n    - Run the pred_sqls (which presumably does an UPSERT on the same (account_id, date)).\n    - Check if we still have exactly one row with the updated amount (30276 + 1000 = 31276).\n    - If there's more than one row or the amount is not updated to 31276, we fail.\n    \"\"\"\n\n    # 1) Drop the table if it exists, to start fresh\n    drop_sql = [\"DROP TABLE IF EXISTS loan CASCADE;\"]\n    execute_queries(drop_sql, db_name, conn)\n\n    # 2) Create a fresh 'loan' table with a unique constraint on (account_id, date)\n    create_sql = [\"\"\"\n        CREATE TABLE loan (\n            loan_id   SERIAL PRIMARY KEY,\n            account_id INT NOT NULL,\n            date       DATE NOT NULL,\n            amount     INT NOT NULL,\n            duration   INT NOT NULL,\n            payments   DOUBLE PRECISION NOT NULL,\n            status     TEXT NOT NULL,\n            UNIQUE(account_id, date)\n        );\n    \"\"\"]\n    execute_queries(create_sql, db_name, conn)\n\n    # 3) Insert an initial record that we expect to update later\n    #    We use the same baseline amount as sol_sqls (30276) so the final will be 31276.\n    init_insert_sql = [\"\"\"\n        INSERT INTO loan (account_id, date, amount, duration, payments, status)\n        VALUES (2, '1996-04-29', 30276, 12, 2500.0, 'X');\n    \"\"\"]\n    execute_queries(init_insert_sql, db_name, conn)\n\n    # 4) Execute the pred_sqls (the user's upsert logic)\n    execute_queries(pred_sqls, db_name, conn)\n\n    # 5) Check how many rows we have for (account_id=2, date='1996-04-29') \n    check_sql = [\"SELECT loan_id, account_id, date, amount FROM loan WHERE account_id=2 AND date='1996-04-29';\"]\n    rows = execute_queries(check_sql, db_name, conn)[0]\n\n    # 6) Evaluate the result\n    assert len(rows) == 1, (\n        f\"Expected only 1 row for (account_id=2, date='1996-04-29'), but found {len(rows)}. \"\n        \"This likely means the upsert inserted a new row instead of updating.\"\n    )\n\n    loan_id_val, acct_val, date_val, amount_val = rows[0]\n\n    # Amount should be updated from 30276 to 31276 (30276 + 1000).\n    expected_amount = 30276 + 1000\n    assert amount_val == expected_amount, (\n        f\"Expected amount={expected_amount} after update, but got {amount_val}. \"\n        \"This likely means the existing row was not updated correctly (or the conflict logic is wrong).\"\n    )"]}
{"instance_id": "397_2", "selected_database": "card_games", "query": "In our card_games database, we have a large table named cards which contains detailed information about each card. We also have two smaller tables, sel1 and sel2, which contain a subset of the cards based on certain criteria. The goal is to delete rows from the cards table where the combination of (uuid, setCode, rarity, manaCost) does not exist in either sel1 or sel2. The current query uses two separate NOT IN clauses, which is both verbose and potentially inefficient. We need to rewrite this query to make it more concise and performant.", "error_sql": ["DELETE FROM cards WHERE (uuid, setCode, rarity, manaCost) NOT IN (SELECT uuid, setCode, rarity, manaCost FROM sel1 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL) AND (uuid, setCode, rarity, manaCost) NOT IN (SELECT uuid, setCode, rarity, manaCost FROM sel2 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL);"], "sol_sql": ["DELETE FROM cards WHERE (uuid, setCode, rarity, manaCost) NOT IN (SELECT uuid, setCode, rarity, manaCost FROM sel1 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL UNION ALL SELECT uuid, setCode, rarity, manaCost FROM sel2 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL);"], "preprocess_sql": ["\nCREATE TABLE sel1 AS SELECT uuid, setCode, rarity, manaCost FROM cards WHERE id % 2 = 0; CREATE TABLE sel2 AS SELECT uuid, setCode, rarity, manaCost FROM cards WHERE id % 3 = 0;\n"], "clean_up_sql": ["\nDROP TABLE sel1; DROP TABLE sel2;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_2 = perform_query_on_postgresql_databases('SELECT COUNT(*) FROM cards WHERE (uuid, setCode, rarity, manaCost) NOT IN (SELECT uuid, setCode, rarity, manaCost FROM sel1 UNION SELECT uuid, setCode, rarity, manaCost FROM sel2);', db_name)[0]\n    assert test_pred_query_result_2[0][0] == 0, f'Expected count to match, but found {pred_query_result[0][0]} and {test_pred_query_result_2[0][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_5 = perform_query_on_postgresql_databases('SELECT uuid, setCode, rarity, manaCost FROM cards WHERE id % 2 != 0 AND id % 3 != 0;', db_name)[0]\n    assert len(test_pred_query_result_5) == 0, f'Expected 0 rows, but found {len(test_pred_query_result_5)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_6 = perform_query_on_postgresql_databases('SELECT COUNT(*) FROM cards;', db_name)[0]\n    assert test_pred_query_result_6[0][0] == 32993, f'Expected to find 32993 rows, but found  {test_pred_query_result_6[0][0]} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    #result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    #assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "], "efficiency": true}
{"instance_id": "359_1", "selected_database": "financial", "query": "In the financial database, I want to apply a forward fill function to all nullable columns of a table. The forward fill function should be applied to each column dynamically, given the table name, an ID column, and a row number column. For example, using the 'trans' table, I want to apply the forward fill to all nullable columns, partitioned by 'account_id' and ordered by 'date'. The function should handle any table with nullable columns and apply the forward fill accordingly. However, my initial attempt at writing the function resulted in a syntax error. I need a corrected version of the function that works for any table with nullable columns.", "error_sql": ["CREATE OR REPLACE FUNCTION f_gap_fill_update(tbl text, id text, row_num text) RETURNS void LANGUAGE plpgsql AS $func$ DECLARE tmp text[]; col text; BEGIN select array ( select column_name from information_schema.columns c where table_name = tbl ) into tmp; foreach col in array tmp loop execute 'update '||tbl||' set '||col||' = gapfill('||col||') OVER w AS '||col||' where '||tbl||'.row_num = '||col||'.row_num window w as (PARTITION BY '||id||' ORDER BY '||row_num||') returning *;'; end loop; end $func$;"], "sol_sql": ["CREATE OR REPLACE FUNCTION f_gap_fill_update(\n    _tbl regclass, \n    _id text, \n    _row_num text, \n    OUT nullable_columns int, \n    OUT updated_rows int\n) LANGUAGE plpgsql AS $func$\nDECLARE \n    _pk text := quote_ident(_row_num); \n    _sql text;\nBEGIN\n    SELECT INTO _sql, nullable_columns concat_ws(E'\n',\n        'UPDATE ' || _tbl || ' t',\n        'SET (' || string_agg(quote_ident(a.attname), ', ') || ') = ',\n        '    (' || string_agg('u.' || quote_ident(a.attname), ', ') || ')',\n        'FROM (',\n        '   SELECT ' || _pk,\n        '        , ' || string_agg(\n                     format(\n                         'COALESCE(%1$I, MAX(%1$I) OVER (PARTITION BY %2$s ORDER BY %3$s ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)) AS %1$I',\n                         a.attname, _id, _pk\n                     ), \n                     ', '\n                 ),\n        '   FROM ' || _tbl,\n        '   ) u',\n        format('WHERE t.%1$s = u.%1$s', _pk),\n        'AND (' || string_agg('t.' || quote_ident(a.attname), ', ') || ') IS DISTINCT FROM',\n        '    (' || string_agg('u.' || quote_ident(a.attname), ', ') || ')'\n    ), \n    count(*)\n    FROM (\n        SELECT a.attname \n        FROM pg_attribute a \n        WHERE a.attrelid = _tbl \n          AND a.attnum > 0 \n          AND NOT a.attisdropped \n          AND NOT a.attnotnull \n        ORDER BY a.attnum\n    ) a;\n\n    RAISE NOTICE 'Generated SQL: %', _sql;\n\n    IF nullable_columns = 0 THEN \n        RAISE EXCEPTION 'No nullable columns found in table >>%<<', _tbl; \n    ELSIF _sql IS NULL THEN \n        RAISE EXCEPTION 'Generated SQL is NULL. Check table or column logic!';\n    END IF;\n\n    EXECUTE _sql;\n\n    GET DIAGNOSTICS updated_rows = ROW_COUNT; \nEND $func$;"], "preprocess_sql": ["CREATE OR REPLACE FUNCTION gap_fill_internal(s anyelement, v anyelement) RETURNS anyelement LANGUAGE plpgsql AS $func$ BEGIN RETURN COALESCE(v, s); END $func$; CREATE AGGREGATE gap_fill(anyelement) ( SFUNC = gap_fill_internal, STYPE = anyelement );"], "clean_up_sql": [""], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    def execute_sqls(sql_list):\n        with conn.cursor() as cur:\n            for sql in sql_list:\n                try:\n                    cur.execute(sql)\n                    conn.commit()\n                except Exception as e:\n                    conn.rollback()\n                    return str(e)\n        return \"success\"\n\n    def validate_forward_fill(limit=10):\n        with conn.cursor() as cur:\n            cur.execute(\"\"\"\n                SELECT t1.trans_id, t1.account_id, t1.amount AS current_amount, t2.amount AS previous_amount\n                FROM trans t1\n                LEFT JOIN trans t2\n                  ON t1.account_id = t2.account_id\n                 AND t1.date > t2.date\n                WHERE t1.amount IS NULL AND t2.amount IS NOT NULL\n                ORDER BY t1.date\n                LIMIT %s;\n            \"\"\", (limit,))\n            rows = cur.fetchall()\n            if rows:\n                return False\n            return True\n\n    def debug_generated_sql():\n        with conn.cursor() as cur:\n            cur.execute(\"\"\"\n                SET client_min_messages TO NOTICE;\n                DO $$\n                BEGIN\n                    PERFORM f_gap_fill_update('trans', 'account_id', 'trans_id');\n                END $$;\n            \"\"\")\n            cur.execute(\"RESET client_min_messages;\") \n\n    def reset_trans_table():\n        with conn.cursor() as cur:\n            cur.execute(\"\"\"\n                UPDATE trans\n                SET amount = CASE\n                    WHEN trans_id = 1 THEN 1000\n                    WHEN trans_id IN (5, 6, 7, 8, 9, 10, 11, 12) THEN NULL\n                    ELSE amount\n                END;\n            \"\"\")\n            conn.commit()\n\n    reset_trans_table()\n    pred_result = execute_sqls(pred_sqls)\n    assert pred_result == \"success\"\n\n    debug_generated_sql()\n    assert validate_forward_fill(), \"Validate forward fill function logic.\"\n\n    return 1"]}
{"instance_id": "360_1", "selected_database": "financial", "query": "In the financial database, there is a table named 'card' that records details of issued cards. Each card is identified by a 'card_id' and is associated with a 'disp_id', along with other details like 'type' and 'issued'. Let's say we want to change the order of a specific 'disp_id' within the same 'type'. For instance, we want to set the 'disp_id' of a card with 'disp_id' = 41 to 1. This change should reorder the 'disp_id' values of all affected cards within the same 'type'. The expected result is that the card with 'disp_id' = 41 should now have 'disp_id' = 1, and the other cards' 'disp_id' values should be incremented accordingly.", "error_sql": ["UPDATE card SET disp_id = 1 WHERE disp_id = 41;"], "sol_sql": ["UPDATE card c\nSET disp_id =\n    CASE \n        WHEN c.disp_id = sub.disp_id THEN 1\n        WHEN c.disp_id < sub.disp_id THEN c.disp_id + 1\n        ELSE c.disp_id\n    END\nFROM (\n    SELECT disp_id, type\n    FROM card\n    WHERE disp_id = 41\n) sub\nWHERE c.type = sub.type\n  AND c.disp_id <= sub.disp_id;"], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the predicted SQLs\n    _, pred_exec_err, _ = execute_queries(pred_sqls, db_name, conn)\n    assert pred_exec_err == False, \"Error in executing predicted SQLs\"\n\n    # Validate the change\n    query = \"SELECT disp_id FROM card WHERE card_id = 1 AND type = 'gold';\"\n    res, _, _ = execute_queries([query], db_name, conn)\n    assert len(res) == 1, \"No matching record found for card_id = 1 and type = 'gold'\"\n    assert res[0][0] == 10, f\"Expected disp_id to be 10, but got {res[0][0]}\"\n\n    return 1"]}
{"instance_id": "361_1", "selected_database": "financial", "query": "I have created the following custom SQL function on a PostgreSQL 16.1 server to generate a series of monthly dates between two given dates for analyzing transaction trends over time:\\nCREATE OR REPLACE FUNCTION public.generate_series_monthly(a date, b date)\\nRETURNS SETOF date LANGUAGE SQL IMMUTABLE PARALLEL SAFE ROWS 12 AS $function$\\nselect generate_series(date_trunc('month', a), date_trunc('month', b), '1 month')\\n$function$;\\nSpecifically, I have added the row estimate parameter, and as expected, I am seeing this estimate in some simple queries:\\nexplain select generate_series_monthly('2023-01-01', '2023-12-01');\\nHowever, in some uses in queries, I see it falling back to the default of 1000:\\nexplain select * from generate_series_monthly('2023-01-01', '2023-12-01');\\nI would expect this second query to also use the 12 row estimate. Why is it resorting to 1000?", "error_sql": ["CREATE OR REPLACE FUNCTION public.generate_series_monthly(a date, b date) RETURNS SETOF date LANGUAGE SQL IMMUTABLE PARALLEL SAFE ROWS 10 AS $function$ select generate_series(date_trunc('month', a), date_trunc('month', b), '1 month') $function$; EXPLAIN SELECT generate_series_monthly('2024-01-01', '2024-05-01'); EXPLAIN SELECT * FROM generate_series_monthly('2024-01-01', '2024-05-01');"], "sol_sql": ["\n  CREATE OR REPLACE FUNCTION public.generate_series_monthly(a date, b date)\n    RETURNS SETOF date\n    LANGUAGE SQL\n    IMMUTABLE\n    PARALLEL SAFE\n    ROWS 10\n  AS\n  $function$\n    SELECT generate_series(\n      date_trunc('month', a),\n      date_trunc('month', b),\n      '1 month'\n    );\n  $function$;\n  ", "\n  EXPLAIN VERBOSE\n  SELECT generate_series_monthly('2024-01-01', '2024-05-01');\n  "], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    \"\"\"\n    Checks if pred_sqls (the tested scenario) produces the same \"rows=10\" estimate\n    as sol_sqls (the correct solution), using assert statements.\n\n    :param pred_sqls: list[str] - SQL statements to be tested\n    :param sol_sqls: list[str] - SQL statements that represent the known correct solution\n    :param db_name: str - name of the database to connect to (if needed)\n    :param conn: psycopg2.extensions.connection - an established DB connection\n    :return: None - the function will raise AssertionError if the conditions are not met\n    \"\"\"\n    def run_sql_and_get_explain_rows(sql_list):\n        \"\"\"\n        Executes a list of SQL statements and returns the output rows of the last\n        EXPLAIN statement (if any).\n        \"\"\"\n        rows_output = []\n        with conn.cursor() as cur:\n            for sql in sql_list:\n                cur.execute(sql)\n                # If it is an EXPLAIN statement, fetch and store its result\n                if sql.strip().upper().startswith(\"EXPLAIN\"):\n                    rows_output = cur.fetchall()\n        return rows_output\n\n    # Run the tested SQL and check for \"rows=10\"\n    pred_explain_rows = run_sql_and_get_explain_rows(pred_sqls)\n    pred_has_rows10 = any(\"rows=10\" in str(row) for row in pred_explain_rows)\n\n    assert pred_has_rows10, (\n        \"Expected to find 'rows=10' in the tested scenario's EXPLAIN output, but it was not found.\"\n    )\n\n    return 1"]}
{"instance_id": "363_1", "selected_database": "european_football_2", "query": "In the context of european_football_2 database whose match table contains columns such as season, date, home_team_goal, away_team_goal, etc. Now, suppose you want to treat any match ending in a draw (home_team_goal = away_team_goal) as if an invoice were being issued (similar to setting Invoiced = 1). Between two such draws, you might have several other matches that do not end in a draw (equivalent to Invoiced = 0), and for each of those matches, you want to treat the total goals scored (i.e., home_team_goal + away_team_goal) like a running amount you accumulate. Finally, you only want to keep the draw rows, and each of those rows should carry the sum of total goals scored since the last draw.", "error_sql": ["SELECT \n    m.id,\n    m.date,\n    CASE WHEN m.home_team_goal = m.away_team_goal THEN 1 ELSE 0 END AS invoiced,\n    SUM(m.home_team_goal + m.away_team_goal)\n        OVER (PARTITION BY (CASE WHEN m.home_team_goal = m.away_team_goal THEN 1 ELSE 0 END)\n              ORDER BY m.id, m.date) AS amount\nFROM match AS m\nORDER BY m.id, m.date;"], "sol_sql": ["WITH cte AS (\n    SELECT\n        m.*,\n        SUM(\n          CASE WHEN m.home_team_goal = m.away_team_goal THEN 1 ELSE 0 END\n        ) OVER (ORDER BY m.date) AS grp\n    FROM match AS m\n),\naggregates AS (\n    SELECT\n        grp,\n        MAX(date) FILTER (WHERE home_team_goal = away_team_goal) AS draw_date,\n        1 AS invoiced,\n        SUM(home_team_goal + away_team_goal) AS total_goals\n    FROM cte\n    GROUP BY grp\n)\nSELECT \n    grp,\n    draw_date AS date,\n    invoiced,\n    total_goals AS amount\nFROM aggregates\nWHERE draw_date IS NOT NULL\nORDER BY grp;"], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "364_1", "selected_database": "debit_card_specializing", "query": "We have a table called transactions_1k that contains transaction details for multiple customers across different gas stations. Each row in this table has:\n1. transaction date\n2. ransaction time\n3. customerid (the ID of the customer)\n4. gasstationid (the ID of the gas station)\n5. productid (the product involved)\n6. amount (the quantity, e.g., liters purchased)\n7. price (the cost)\n\nWe want to filter these transactions under the following rules, per customer:\n1.  Only the last transaction at each gas station should be considered.\n2.  If the customer has any transaction where amount < 10 (which indicates a potential issue), display the first gas station on which that issue occurred.\n3.  If the customer has no transactions with amount < 10, then display the last gas station on which the customer had a transaction with amount >= 10.\n\nGiven some sample data, we expect the final output to show only:\n1. The last transaction for each gas station where amount >= 10.\n2. The first transaction for each gas station where amount < 10.\n\nWe attempted the following SQL query in PostgreSQL to achieve this, but it does not return the desired results. Instead, it only picks the gas station with the maximum gasstationid for each customer and does not correctly determine the earliest occurrence of amount < 10 chronologically. In other words, this query fails to implement the last transaction per gas station and the first station where amount < 10 correctly.", "error_sql": ["WITH DataSource AS (\n  SELECT\n    *,\n    MIN(CASE WHEN amount < 10 THEN gasstationid END) \n      OVER (PARTITION BY customerid) AS first_issue_gasstation,\n    ROW_NUMBER() OVER (PARTITION BY customerid ORDER BY gasstationid DESC) AS gasstation_id\n  FROM transactions_1k\n  WHERE gasstationid = (\n    SELECT MAX(gasstationid)\n    FROM transactions_1k\n    WHERE customerid = transactions_1k.customerid\n  )\n)\nSELECT \n  customerid,\n  transactionid,\n  gasstationid,\n  amount\nFROM DataSource\nWHERE\n  (first_issue_gasstation IS NULL AND gasstation_id = 1)\n  OR (first_issue_gasstation = gasstationid);"], "sol_sql": ["WITH last_per_station AS (\n  SELECT\n    t.*,\n    ROW_NUMBER() OVER (\n      PARTITION BY customerid, gasstationid\n      ORDER BY transactionid DESC\n    ) AS rn\n  FROM transactions_1k t\n),\nDataSource AS (\n  SELECT\n    lps.*,\n    CASE WHEN amount < 10 THEN transactionid END AS fail_id,\n    CASE WHEN amount >= 10 THEN transactionid END AS pass_id\n  FROM last_per_station lps\n  WHERE rn = 1\n),\nCalculated AS (\n  SELECT\n    ds.*,\n    MIN(fail_id) OVER (PARTITION BY customerid) AS earliest_fail_id,\n    MAX(pass_id) OVER (PARTITION BY customerid) AS last_pass_id\n  FROM DataSource ds\n)\nSELECT\n  customerid,\n  transactionid,\n  date,\n  time,\n  gasstationid,\n  productid,\n  amount,\n  price\nFROM Calculated\nWHERE\n  (earliest_fail_id IS NOT NULL AND fail_id = earliest_fail_id)\n  OR\n  (earliest_fail_id IS NULL AND pass_id = last_pass_id);"], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "540_2", "selected_database": "superhero", "query": "In the superhero database, we have a directed acyclic graph representing the lineage of superheroes. Each superhero has a unique identifier and a parent identifier, which points to their predecessor in the lineage. Given two superheroes, 'Superhero A' and 'Superhero B', we need to find their common ancestor in the lineage. The provided query is inefficient as it traverses the entire lineage until it finds the root, which is not optimal when the common segment of the lineage is large. We need to find an efficient way to determine the common ancestor with a complexity of O(A+B) where A and B are the number of nodes in the lineages of 'Superhero A' and 'Superhero B', respectively.", "error_sql": ["WITH RECURSIVE linked_list(id, parent_id) AS (SELECT id, parent_id FROM lineage WHERE id = 1001 OR id = 1201 UNION ALL SELECT g.id, g.parent_id FROM lineage g INNER JOIN linked_list ll ON ll.parent_id = g.id) SELECT string_agg(id::TEXT, ',') AS ids, parent_id FROM linked_list GROUP BY parent_id HAVING COUNT(DISTINCT id) > 1;"], "sol_sql": ["WITH RECURSIVE linked_list(id, parent_id, depth) AS (SELECT id, parent_id, 0 FROM lineage WHERE id = 1001 OR id = 1201 UNION ALL SELECT g.id, g.parent_id, ll.depth + 1 FROM lineage g INNER JOIN linked_list ll ON ll.parent_id = g.id WHERE depth < 10000) SELECT string_agg(id::TEXT, ',') AS ids, parent_id FROM linked_list GROUP BY parent_id HAVING COUNT(DISTINCT id) > 1;"], "preprocess_sql": ["CREATE TABLE lineage (id INT PRIMARY KEY, parent_id INT);", "INSERT INTO lineage (id, parent_id) SELECT i, CASE WHEN i = 1 THEN NULL ELSE i - 1 END FROM generate_series(1, 1000) AS i;", "INSERT INTO lineage (id, parent_id) SELECT 1000 + i, 1000 + i - 1 FROM generate_series(1, 200) AS i;", "INSERT INTO lineage (id, parent_id) SELECT 1200 + i, 1000 + i - 1 FROM generate_series(1, 200) AS i;"], "clean_up_sql": "DROP TABLE lineage;", "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "], "efficiency": true}
{"instance_id": "541_1", "selected_database": "card_games", "query": "In a digital card trading platform, users perform various actions such as `LOGIN`, `SEARCH`, and `BUY`. An abandoned `SEARCH` action is defined as when a user `LOGIN`s, performs one or more `SEARCH` actions, and does not perform a `BUY` action before the next `LOGIN`. Given a table `user_actions` that records `user_id`, `action`, and `action_time`, determine all abandoned `SEARCH` actions.", "error_sql": ["SELECT c1.user_id, COUNT(*) FROM user_actions c1 LEFT JOIN (SELECT user_id, action, action_time FROM user_actions WHERE action = 'LOGIN') c2 ON c1.user_id = c2.user_id AND c2.action_time > c1.action_time LEFT JOIN (SELECT user_id, action, action_time FROM user_actions WHERE action = 'BUY') c3 ON c1.user_id = c3.user_id AND c3.action_time > c1.action_time AND c3.action_time < c2.action_time WHERE c1.action = 'SEARCH' AND c2.user_id IS NOT NULL AND c3.user_id IS NULL GROUP BY 1"], "sol_sql": ["SELECT * FROM user_actions AS a WHERE a.action = 'SEARCH' AND NOT EXISTS (SELECT 1 FROM user_actions WHERE user_id = a.user_id AND action = 'BUY' AND action_time > a.action_time AND (action_time < (SELECT MIN(action_time) FROM user_actions WHERE user_id = a.user_id AND action = 'LOGIN' AND action_time > a.action_time) OR (SELECT MIN(action_time) FROM user_actions WHERE user_id = a.user_id AND action = 'LOGIN' AND action_time > a.action_time) IS NULL));"], "preprocess_sql": ["CREATE TABLE user_actions(user_id VARCHAR(1) NOT NULL, action VARCHAR(6) NOT NULL, action_time DATE NOT NULL);", "INSERT INTO user_actions(user_id, action, action_time) VALUES ('A', 'LOGIN', '2023-05-01'), ('A', 'SEARCH', '2023-05-02'), ('A', 'SEARCH', '2023-05-03'), ('A', 'BUY', '2023-05-04'), ('B', 'LOGIN', '2023-05-01'), ('B', 'SEARCH', '2023-05-02'), ('B', 'SEARCH', '2023-05-03'), ('B', 'LOGIN', '2023-05-04'), ('B', 'SEARCH', '2023-05-05')"], "clean_up_sql": ["DROP TABLE user_actions"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "543_1", "selected_database": "card_games", "query": "In the card_games database, there is a table named 'cards' which contains various details about each card, including a unique identifier 'id' and the card's name 'name'. Another table named 'decks' stores information about different decks, where each deck has a unique identifier 'id' and an array 'card_order' that lists the 'id's of the cards in the deck in the order they should be played. When a user selects a deck, they want to see the cards in the order they are listed in the 'card_order' array. However, the current SQL query does not preserve the order of the cards as specified in the 'card_order' array. The user's current SQL query is provided below and it does not maintain the order of the cards.", "error_sql": ["SELECT c.id, c.name FROM cards c WHERE c.id IN (SELECT unnest(card_order) FROM decks WHERE id = 1);"], "sol_sql": ["SELECT cte.id, c.name FROM (SELECT card_order FROM decks WHERE id = 1) d  CROSS JOIN UNNEST(d.card_order) WITH ORDINALITY cte(id, idx)  INNER JOIN cards c ON c.id = cte.id ORDER BY cte.idx;"], "preprocess_sql": ["CREATE TABLE decks (id bigint PRIMARY KEY, card_order bigint[]);", "INSERT INTO decks (id, card_order) VALUES (1, ARRAY[3, 6, 1]), (2, ARRAY[5, 2, 4]);"], "clean_up_sql": ["DROP TABLE decks;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "545_1", "selected_database": "card_games", "query": "In the context of the card_games database, we have two tables: 'card_prices' and 'order_cards'. The 'card_prices' table records the price of each card at different start dates, and the 'order_cards' table records the cards ordered by customers on specific dates. We need to join these two tables to get the price of each card at the time it was ordered. However, the initial attempt to join the tables resulted in duplicate records for some orders. Here are the tables and the problematic query:\\n\\Table 'card_prices':\\n| start_date | card_id | price |\\n|------------|---------|-------|\\n| 2023-04-01 | 1       | 10.0  |\\n| 2023-04-15 | 1       | 20.0  |\\n| 2023-04-01 | 2       | 20.0  |\\n\\Table 'order_cards':\\n| order_date | order_id | card_id |\\n|------------|----------|---------|\\n| 2023-04-01 | 10001    | 1       |\\n| 2023-04-01 | 10001    | 2       |\\n| 2023-04-02 | 10002    | 1       |\\n| 2023-04-02 | 10002    | 2       |\\n| 2023-04-16 | 10003    | 1       |\\n| 2023-04-16 | 10003    | 2       |\\n\\nThe desired result is:\\n| order_date | order_id | card_id | price |\\n|------------|----------|---------|-------|\\n| 2023-04-01 | 10001    | 1       | 10.0  |\\n| 2023-04-01 | 10001    | 2       | 20.0  |\\n| 2023-04-02 | 10002    | 1       | 10.0  |\\n| 2023-04-02 | 10002    | 2       | 20.0  |\\n| 2023-04-16 | 10003    | 1       | 20.0  |\\n| 2023-04-16 | 10003    | 2       | 20.0  |\\nHowever, the initial attempt resulted in duplicate records for some orders.\\n", "error_sql": ["SELECT ord.order_date, ord.order_id, ord.card_id, prd.price FROM order_cards ord LEFT JOIN (SELECT * FROM card_prices ORDER BY start_date ASC) AS prd ON ord.card_id = prd.card_id AND ord.order_date >= prd.start_date"], "sol_sql": ["SELECT ord.*, prd.price FROM order_cards ord LEFT JOIN LATERAL (SELECT prd.* FROM card_prices prd WHERE prd.card_id = ord.card_id and prd.start_date <= ord.order_date ORDER BY start_date DESC LIMIT 1) prd ON TRUE"], "preprocess_sql": ["CREATE TABLE card_prices (start_date DATE, card_id BIGINT, price NUMERIC);", "INSERT INTO card_prices (start_date, card_id, price) VALUES ('2023-04-01', 1, 10.0), ('2023-04-15', 1, 20.0), ('2023-04-01', 2, 20.0);", "CREATE TABLE order_cards (order_date DATE, order_id BIGINT, card_id BIGINT);", "INSERT INTO order_cards (order_date, order_id, card_id) VALUES ('2023-04-01', 10001, 1), ('2023-04-01', 10001, 2), ('2023-04-02', 10002, 1), ('2023-04-02', 10002, 2), ('2023-04-16', 10003, 1), ('2023-04-16', 10003, 2);"], "clean_up_sql": ["DROP TABLE card_prices;", "DROP TABLE order_cards;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "546_1", "selected_database": "european_football_2", "query": "In the database 'european_football_2', there is a table named 'player_stats' that records the performance statistics of football players across different matches. Each row in the table represents a player's performance in a specific match. The table has two columns, 'stats_keys' and 'stats_values', which store the performance metrics and their corresponding values as comma-separated strings. For example, 'stats_keys' might contain 'goals,assists,yellow_cards' and 'stats_values' might contain '2,1,0'. The task is to transform this table into a format where each performance metric is a separate column, with the corresponding values filled in for each player's match performance.", "error_sql": ["select player_id, stats_keys, stats_values from player_stats"], "sol_sql": ["SELECT player_id, cols ->> 'goals' AS goals, cols ->> 'assists' AS assists, cols ->> 'yellow_cards' AS yellow_cards, cols ->> 'red_cards' AS red_cards FROM (SELECT player_id, (SELECT jsonb_object_agg(k, v) FROM unnest(string_to_array(stats_keys, ','), string_to_array(stats_values, ',')) AS x(k, v)) AS cols FROM player_stats) x ORDER BY player_id;"], "preprocess_sql": ["CREATE TABLE player_stats (player_id INT, stats_keys TEXT, stats_values TEXT);", "INSERT INTO player_stats (player_id, stats_keys, stats_values) VALUES (1, 'goals,assists,yellow_cards', '2,1,0'), (2, 'assists,yellow_cards', '0,1'), (3, 'goals,yellow_cards', '1,0'), (4, 'assists,yellow_cards,red_cards', '2,1,0');"], "clean_up_sql": ["DROP TABLE player_stats;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "548_1", "selected_database": "european_football_2", "query": "In the 'european_football_2' database, there is a table named 'teams_config' which holds information about various football teams. Each team has a 'configurations' column of type jsonb that stores an array of objects representing different team settings. Each object in the array has an 'id', 'name', and 'settings'. For example, one row in the 'teams_config' table might have the following 'configurations':\n[\n    {\n             \"id\": 100, \n            \"name\": \"testOne\", \n            \"settings\": \"settingOne\" \n       },\n         {\n            \"id\": 101,\n            \"name\": \"testTwo\",\n            \"settings\": \"settingTwo\"\n        },\n]", "error_sql": ["UPDATE teams_config SET configurations = jsonb_set(configurations, '{settings}', (configurations->'id') - (SELECT DISTINCT position - 1 FROM teams_config, jsonb_array_elements(configurations) WITH ORDINALITY arr(elem, position) WHERE elem->>'id' = '101')::int);"], "sol_sql": ["UPDATE teams_config t SET configurations = (SELECT jsonb_agg(a.elem) FROM jsonb_array_elements(t.configurations) AS a(elem) WHERE (a.elem ->> 'id' = '101') IS NOT TRUE) WHERE t.configurations @> '[{\"id\":101}]';"], "preprocess_sql": ["CREATE TABLE teams_config (configurations jsonb);", "INSERT INTO teams_config VALUES ('[{\"id\": 100, \"name\": \"testOne\", \"settings\": \"settingOne\"}, {\"id\": 101, \"name\": \"testTwo\", \"settings\": \"settingTwo\"}]');"], "clean_up_sql": ["DROP TABLE teams_config"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_sqls_result = execute_queries([\"SELECT * FROM teams_config;\"], db_name, conn)[0]\n    assert test_pred_sqls_result[0][0] == [{'id': 100, 'name': 'testOne', 'settings': 'settingOne'}], f'Expected the object with id = 101 is deleted and only the object with id = 100 is left in the configurations column. But got: {test_pred_sqls_result[0][0]}'\n"]}
{"instance_id": "549_3", "selected_database": "formula_1", "query": "I have a table race_dates which stores the begin_date and end_date of races, e.g. '2022-01-03' and '2022-03-04', is there any neat way to calculate ONLY the completed full calendar months between these dates? Some examples with their requested outputs: '2022-01-03' and '2022-03-04' full calendar months = 1 since only February was a full calendar month between this timespan. '2022-01-01' and '2022-05-30' full calendar months = 4 since May has 31 days total. '2022-01-31' and '2022-05-31' full calendar months = 3 since the month of May is not completed. I tried subtracting the dates but it gives me the days difference between these dates. I also tried the function AGE() but it is based also in the days difference, since it is using days to calculate years months etc.", "error_sql": ["SELECT begin_date, end_date, age(CASE WHEN end_date = date_trunc('month', end_date) + interval '1 month - 1 day' THEN end_date + interval '1 day' ELSE date_trunc('month', end_date) END::date, CASE WHEN begin_date = date_trunc('month', begin_date) THEN begin_date ELSE date_trunc('month', begin_date) + interval '1 month' END::date) AS calculated_months FROM race_dates;"], "sol_sql": ["SELECT begin_date, end_date, (DATE_PART('year', end_date) - DATE_PART('year', begin_date)) * 12 + DATE_PART('month', end_date) - DATE_PART('month', begin_date) - CASE WHEN begin_date > date_trunc('month', begin_date) THEN 1 ELSE 0 END AS full_calendar_months FROM race_dates;"], "preprocess_sql": ["CREATE TABLE race_dates (begin_date DATE NOT NULL, end_date DATE NOT NULL)", "INSERT INTO race_dates (begin_date, end_date) VALUES ('2022-01-03', '2022-03-04'), ('2022-01-01', '2022-05-30'), ('2022-01-31', '2022-05-31'), ('2021-11-15', '2022-02-10'), ('2021-12-01', '2022-05-31');"], "clean_up_sql": ["DROP TABLE race_dates"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "342_1", "selected_database": "student_club", "query": "In the student_club database, I am trying to insert an attendance record that tracks when a member attends an event. The goal is to ensure there are no duplicate entries for the same member (link_to_member) attending the same event (link_to_event). If an attendance record for the member and event already exists, the date column should be updated to reflect the most recent attendance timestamp. If no such record exists, a new record should be created. I have tried using the ON CONFLICT clause with a WHERE condition to achieve this, but it doesn't seem to work.\nHere is one of the many permutations I've tried:\n\nsql\nINSERT INTO new_attendance (link_to_event, link_to_member, date) \nVALUES ('reciRZdAqNIKuMC96', 'recL94zpn6Xh6kQii', NOW()) \nON CONFLICT \n   WHERE link_to_member='recL94zpn6Xh6kQii' DO NOTHING\n\n\nThe link_to_member column does not have any constraints, so the simpler syntax:\n\nsql\nON CONFLICT (link_to_member) DO NOTHING\n\n\nthrows database errors. My hope is this is a simple syntax issue.", "error_sql": ["\n    INSERT INTO new_attendance (link_to_event, link_to_member, date)\n    VALUES ('reciRZdAqNIKuMC96', 'recL94zpn6Xh6kQii', NOW())\n    ON CONFLICT\n    WHERE link_to_member='recL94zpn6Xh6kQii' DO NOTHING;\n    "], "sol_sql": ["\n    INSERT INTO new_attendance (\n        link_to_event, \n        link_to_member, date\n    ) VALUES ('reciRZdAqNIKuMC96', 'recL94zpn6Xh6kQii', NOW())\n    ON CONFLICT (link_to_event, link_to_member) DO UPDATE SET\n        date = NOW();\n    "], "preprocess_sql": ["\n    DROP TABLE IF EXISTS new_attendance;\n    ", "\n    CREATE TABLE new_attendance AS\n    SELECT DISTINCT link_to_event, link_to_member, NOW() AS date\n    FROM attendance;\n    ", "\n    ALTER TABLE new_attendance\n    ADD CONSTRAINT unique_event_member UNIQUE (link_to_event, link_to_member);\n    "], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries(pred_sqls,db_name,conn)\n    queries = [\"SELECT * FROM new_attendance WHERE link_to_event = 'reciRZdAqNIKuMC96' AND link_to_member = 'recL94zpn6Xh6kQii';\"]\n    res,_,_ = execute_queries(queries,db_name,conn)\n    assert len(res) == 1\n    ori_date = res[0][-1]\n    execute_queries(pred_sqls,db_name,conn)\n    res,_,_ = execute_queries(queries,db_name,conn)\n    assert len(res) == 1\n    new_date = res[0][-1]\n    assert ori_date != new_date\n    "]}
{"instance_id": "343_2", "selected_database": "toxicology", "query": "I have a table in my toxicology database that represents the connections between atoms and bonds. The table is named 'connected' and it has a foreign key constraint on the 'bond_id' column referencing the 'bond_id' column in the 'bond' table. Initially, the foreign key constraint was set with the default 'ON DELETE NO ACTION' behavior. However, I realized that I need to change this behavior to 'ON DELETE RESTRICT' to prevent accidental deletions. I tried to alter the constraint, but I encountered an error. I need to know the correct syntax to alter the 'ON DELETE' action for this foreign key constraint.", "error_sql": ["\n        ALTER table connected\n        DROP CONSTRAINT connected_bond_id_fkey ;\n        ALTER TABLE connected  \n            ADD CONSTRAINT connected_bond_id_fkey \n            FOREIGN KEY (bond_id) REFERENCES connected(bond_id) ON DELETE RESTRICT;\n        "], "sol_sql": ["\n    ALTER table  connected\n    DROP CONSTRAINT connected_bond_id_fkey,\n    ADD CONSTRAINT connected_bond_id_fkey \n    FOREIGN KEY (bond_id) REFERENCES bond(bond_id) ON DELETE RESTRICT;          \n    "], "preprocess_sql": ["ALTER TABLE connected DROP CONSTRAINT IF EXISTS connected_bond_id_fkey;", "\n    ALTER TABLE connected\n    ADD CONSTRAINT connected_bond_id_fkey\n    FOREIGN KEY (bond_id)\n    REFERENCES bond(bond_id);\n    "], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pass\n    "]}
{"instance_id": "344_1", "selected_database": "financial", "query": "I'm migrating from Oracle to PostgreSQL. In Oracle, I used the following call to acquire a lock with a timeout: `lkstat := DBMS_LOCK.REQUEST(lkhndl, DBMS_LOCK.X_MODE, lktimeout, true);`. This function tries to acquire the lock `lkhndl` and returns 1 if it fails to get it after `lktimeout` seconds. In PostgreSQL, I tried using `pg_advisory_xact_lock(lkhndl);`, but it seems to wait indefinitely for the lock.     I need a way to implement a timeout version of lock acquiring in PostgreSQL named pg_try_advisory_lock_with_timeout. The function pg_try_advisory_lock_with_timeout(key bigint) is designed to attempt to acquire a PostgreSQL advisory lock with a timeout of 1 second. If the lock is unavailable due to contention or deadlock detection, it will return false instead of waiting indefinitely.", "error_sql": ["\n        pg_advisory_xact_lock(lkhndl);\n        "], "sol_sql": ["\n        CREATE FUNCTION pg_try_advisory_lock_with_timeout(key bigint) RETURNS boolean\n        SET lock_timeout TO '1s'\n        AS $$\n        BEGIN\n        PERFORM pg_advisory_lock(key);\n        RETURN true;\n        EXCEPTION\n        WHEN lock_not_available OR deadlock_detected THEN\n            RETURN false;\n        END;\n        $$\n        LANGUAGE plpgsql;          \n        "], "preprocess_sql": ["\n    DROP FUNCTION IF EXISTS pg_try_advisory_lock_with_timeout(bigint);\n    "], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\"SELECT pg_try_advisory_lock_with_timeout(12345);\"]\n    res, _, _ = execute_queries(queries,db_name,conn)\n    print(res)\n    assert res[0][0] == True or res[0][0] == False\n    "]}
{"instance_id": "345_3", "selected_database": "student_club", "query": "I'm trying to rank club members based on the hours they have attented for events, rounded to the nearest 10. I need to produce a descending ranking of members by total hours attened, including a column with the rank using the `RANK()` window function, and sort the result by the rank. However, my rounding logic seems to be incorrect, as it produces different results compared to the expected output.", "error_sql": ["\n        SELECT\n            link_to_member,\n            CASE\n                WHEN (SUBSTRING(ROUND(SUM(hours)::NUMERIC, 0)::TEXT FROM '.{1}$') IN ('5', '6', '7', '8', '9', '0')) \n                THEN CEIL(SUM(hours) / 10) * 10\n                ELSE FLOOR(SUM(hours) / 10) * 10\n            END AS rounded_hours,\n            RANK() OVER (ORDER BY \n                CASE\n                    WHEN (SUBSTRING(ROUND(SUM(hours)::NUMERIC, 0)::TEXT FROM '.{1}$') IN ('5', '6', '7', '8', '9', '0')) \n                    THEN CEIL(SUM(hours) / 10) * 10\n                    ELSE FLOOR(SUM(hours) / 10) * 10\n                END DESC\n            ) AS rank\n        FROM attendance\n        GROUP BY link_to_member\n        ORDER BY rank, link_to_member;      \n        "], "sol_sql": ["\n        SELECT\n            link_to_member,\n            ROUND(SUM(hours)::NUMERIC, -1) AS rounded_hours,\n            RANK() OVER (ORDER BY ROUND(SUM(hours)::NUMERIC, -1) DESC) AS rank\n        FROM attendance\n        GROUP BY link_to_member\n        ORDER BY rank, link_to_member;\n        "], "preprocess_sql": ["\n    ALTER TABLE attendance\n    ADD COLUMN hours NUMERIC;\n    ", "\n    TRUNCATE TABLE attendance;\n    ", "\n    INSERT INTO attendance (link_to_event, link_to_member, hours)\n    VALUES \n    ('event_1', 'member_1', 64.5),\n    ('event_2', 'member_1', 60.0),\n    ('event_2', 'member_2', 210.5),\n    ('event_3', 'member_3', 237.6);\n    "], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert int(pred_query_result[-1][1]) == 120\n    "]}
{"instance_id": "346_1", "selected_database": "financial", "query": "I need to create an index named ix_account on the 'account' table for the columns 'district_id', 'frequency', and 'date'. I want to ensure that the index does not already exist before attempting to create it. How can I check for the existence of this index? Return True if the index exists. Otherwise return False.", "error_sql": ["\n        CREATE INDEX ix_account ON account USING btree (district_id, frequency, date);   \n        "], "sol_sql": ["\n        SELECT \n            CASE \n                WHEN EXISTS (\n                    SELECT 1 \n                    FROM pg_indexes \n                    WHERE tablename = 'account' \n                    AND indexname = 'ix_account'\n                ) THEN TRUE\n                ELSE FALSE\n            END AS index_exists;\n        "], "preprocess_sql": ["\n        CREATE INDEX ix_account ON account USING btree (district_id, frequency, date);   \n        "], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert pred_query_result[0][0] == True\n    queries = [\"DROP INDEX ix_account;\"]\n    execute_queries(queries,db_name,conn)\n    res, _, _ = execute_queries(pred_sqls,db_name,conn)\n    assert res[0][0] == False\n    "]}
{"instance_id": "347_2", "selected_database": "european_football_2", "query": "I am trying to create a view that counts the records where home team goal is 2 in a specific season.     I have a function `findteam(text)` that returns a float representing the count for a given season.    However, when I try to use this function in my view, I encounter an error stating 'cannot change data type of view column `team_count` from integer to double precision'.     I am new to SQL and do not understand why this is happening or how to fix it.", "error_sql": ["\n        create or replace view findcount(season, team_count) as\n        select\n            season,\n            findteam(season) as team_count\n        from (\n            select distinct season\n            from match\n            where season >= '2008/2009' \n        ) seasons;\n        "], "sol_sql": ["\n        drop view findcount;\n        create or replace view findcount(season, team_count) as\n        select\n            season,\n            findteam(season) as team_count\n        from (\n            select distinct season\n            from match\n            where season >= '2008/2009' \n        ) seasons;\n        "], "preprocess_sql": ["\n    DROP VIEW IF EXISTS findcount;\n    DROP FUNCTION IF EXISTS findteam;\n    ", "\n    create or replace function findteam(text) returns float as $$\n    select cast(count(*) as float)\n    from match m\n    where m.home_team_goal = 2 and m.season = $1;\n    $$ language sql;\n    ", "\n    CREATE VIEW findcount AS\n    SELECT season, CAST(10 AS INTEGER) AS team_count\n    from (\n            select distinct season\n            from match\n            where season >= '2008/2009' \n        ) seasons;\n    "], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\n        \"\"\"\n        SELECT \n            CASE \n                WHEN pg_type.typname = 'float8' THEN TRUE \n                ELSE FALSE \n            END AS is_float\n        FROM pg_attribute\n        JOIN pg_class ON pg_attribute.attrelid = pg_class.oid\n        JOIN pg_type ON pg_attribute.atttypid = pg_type.oid\n        WHERE pg_class.relname = 'findcount' \n        AND pg_attribute.attname = 'team_count'\n        AND pg_attribute.attnum > 0;\n        \"\"\"\n    ]\n    \n    res, _, _ = execute_queries(queries,db_name,conn)\n    assert res[0][0] == True\n    "]}
{"instance_id": "348_3", "selected_database": "codebase_community", "query": "In the context of the 'codebase_community' database, a user has a table named 'posts' containing various posts made by users. Each post has a 'tags' column    that lists the tags associated with the post. Specifically, the user is interested in identifying the number of posts that include the keywords 'bayesian' or 'distributions' for each post type.    The user attempted to implement this in PostgreSQL but encountered errors in his SQL query.", "error_sql": ["\n        select posttypeid\n        case when tags like ('%bayesian%','%distributions%') \n        then 1 else 0 end as keyword_count\n        from posts\n        "], "sol_sql": ["\n        select posttypeid,\n        sum(case when tags like '%bayesian%'\n                or tags like '%distributions%'\n            then 1 else 0 end) as keyword_count\n        from posts\n        group by posttypeid\n        "], "preprocess_sql": ["\n    ALTER TABLE posts RENAME TO posts_backup;\n    ", "\n    CREATE TABLE posts (\n    id INT PRIMARY KEY,\n    posttypeid INT,\n    tags TEXT\n    );\n    ", "\n    INSERT INTO posts (id, posttypeid, tags)\n    VALUES \n    (1, 1, '<bayesian><prior><elicitation>'),\n    (2, 1, '<distributions><normality>'),\n    (3, 1, '<software><open-source>'),\n    (4, 2, '<distributions>'),\n    (5, 2, '<book><code>');\n    ", "\n    DROP TABLE IF EXISTS posts_backup;\n    "], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert pred_query_result[0][0] == 2\n    assert pred_query_result[0][1] == 1\n    assert pred_query_result[1][0] == 1\n    assert pred_query_result[1][1] == 2\n    "]}
{"instance_id": "399_1", "selected_database": "debit_card_specializing", "query": "I have a table with 80 000 000 rows which are geopoints from 20 000 different gid. For each gid i have like thousands of gepoints (ex gid 1 ==> 5097 rows). Some of the geopoints are the same (like the three first points in my example above) and i want for each idx_pt to find the first geopoint of the gid When identified i need to update the id_unique columns with the idx_pt of the first point found.I succeed to perform this update but i have a problem of performance. I run my postgresql server on a small server (nas synology) and the query is running for more than 24 hours now and just 50 percent of the query is done ... to be sure that even if the server closed prematurally i keep the update rows i do a for loop update with a commit instruction for each gid. The logic is : for each idx_pt i do a lateral join based on the same gid, same geopoints ordered by the idx_pt column and keeping only the first rows.this query take 12 seconds to perform on my little server (5097 rows X 5097 rows) My problem is than i have 20 000 gid for a total of 80 000 000 rows so it is very very slow. My Question : how could i improve the performance for this task ?", "error_sql": ["SELECT a.gid, a.idx_pt, (SELECT b.idx_pt FROM test b WHERE b.gid = a.gid AND b.x = a.x AND b.y = a.y ORDER BY b.idx_pt LIMIT 1) AS id_unique, a.x, a.y, a.geom FROM test a ORDER BY a.gid, a.idx_pt"], "sol_sql": ["SELECT gid, idx_pt, FIRST_VALUE(idx_pt) OVER (PARTITION BY gid, geom ORDER BY idx_pt RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS id_unique, x, y, geom FROM test WHERE gid = 1 ORDER BY gid, idx_pt"], "preprocess_sql": ["\nCREATE TABLE test (\n  gid int,\n  idx_pt int,\n  id_unique varchar(10),\n  x numeric,\n  y numeric,\n  geom text\n);\nINSERT INTO test (gid, idx_pt, id_unique, x, y, geom) VALUES\n(1, 1, 'na', 65250.78, 700000.52, '01010000206A0000000000F0C02E458A4400000000F03F'),\n(1, 2, 'na', 65250.78, 700000.52, '01010000206A0000000000F0C02E458A4400000000F03F'),\n(1, 3, 'na', 65250.78, 700000.52, '01010000206A0000000000F0C02E458A4400000000F03F'),\n(1, 4, 'na', 65999.00, 700555.00, '01010000455A000000000010C03F478A4400000010F03F'),\n(1, 5, 'na', 65999.00, 700555.00, '01010000455A000000000010C03F478A4400000010F03F'),\n(1, 6, 'na', 65999.00, 700555.00, '01010000455A000000000010C03F478A4400000010F03F');            \n"], "clean_up_sql": ["\nDROP TABLE test;\n"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "], "efficiency": true}
{"instance_id": "542_2", "selected_database": "toxicology", "query": "In the toxicology database, I have two tables, 'bond' and 'molecule'. The 'bond' table contains information about bonds within molecules, including a foreign key 'molecule_id' that references the 'molecule' table. I need to construct a query that select count(*), molecule_id, most recent update timestamp grouping the bonds by 'molecule_id' and sorts the results based on molecule_id and the most recent bond entry (assuming we have a timestamp column added to the 'bond' table for this purpose). However, I've tried the following query and it doesn't work as expected:", "error_sql": ["SELECT count(bond_id), molecule_id FROM bond GROUP BY molecule_id ORDER BY molecule_id last_update DESC;"], "sol_sql": ["SELECT count(bond_id), molecule_id FROM bond GROUP BY molecule_id ORDER BY molecule_id, MAX(last_update) DESC"], "preprocess_sql": ["ALTER TABLE bond ADD COLUMN last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP;"], "clean_up_sql": ["ALTER TABLE bond DROP COLUMN last_update;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "544_2", "selected_database": "european_football_2", "query": "In the context of the 'european_football_2' database, we have a table that logs changes to player statistics over time. Each row in the 'player_stats_changes' table represents a change to a specific player's attribute (such as height or weight) at a particular timestamp. We want to generate a cumulative view of these changes, where each row shows the player's current height and weight at each timestamp, filling in any missing values with the most recent known value.", "error_sql": ["SELECT entity_id, coalesce(change->'height', lag(change->'height', 1, null) over (partition by entity_id order by updated_at)) as height, coalesce(change->'weight', lag(change->'weight', 1, null) over (partition by entity_id order by updated_at)) as weight, updated_at FROM ( SELECT entity_id, json_object_agg(column_id, value) as change, updated_at FROM player_stats_changes GROUP BY entity_id, updated_at) as changes;"], "sol_sql": ["SELECT entity_id, coalesce(height, lag(height, 1, null) OVER (PARTITION BY entity_id ORDER BY updated_at)) AS height, coalesce(weight, lag(weight, 1, null) OVER (PARTITION BY entity_id ORDER BY updated_at)) AS weight, updated_at FROM (SELECT entity_id, MAX(CASE WHEN column_id = 'height' THEN value::int END) AS height, MAX(CASE WHEN column_id = 'weight' THEN value::int END) AS weight, updated_at FROM player_stats_changes GROUP BY entity_id, updated_at) AS changes;"], "preprocess_sql": ["CREATE TABLE IF NOT EXISTS player_stats_changes ( entity_id TEXT NOT NULL, column_id TEXT NOT NULL, value JSONB NOT NULL, updated_at TIMESTAMP NOT NULL );", "INSERT INTO player_stats_changes VALUES ('1', 'height', to_jsonb(140), '01-01-2021 00:00:00'::TIMESTAMP), ('1', 'weight', to_jsonb(30), '01-01-2021 00:00:00'::TIMESTAMP), ('1', 'height', to_jsonb(145), '01-02-2021 00:00:00'::TIMESTAMP), ('1', 'weight', to_jsonb(34), '01-03-2021 00:00:00'::TIMESTAMP);"], "clean_up_sql": ["DROP TABLE IF EXISTS player_stats_changes;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    result = 0 if any('json_object_agg' in sql.lower() for sql in pred_sqls) else 1\n    assert result == 1, f\"Expected 1 because json_object_agg includes redundant aggregations which is not allowed, but got {result}.\"\n    return result"]}
{"instance_id": "550_1", "selected_database": "superhero", "query": "In the superhero database, I have two separate queries (q1, q2) joining across multiple tables assigning the same superheroes to different groups (I call these subgroups) based on different criteria. I get query result 1 and 2 (qr1, qr2). An item might appear in one or both, but within a result it is unique. I want to assign a new group id based on both subgroups and assigning the same group id if the subgroups share one or more items.", "error_sql": ["with qr1(item, subgroup) AS (SELECT id, subgroup1 FROM superhero_group WHERE subgroup1 IS NOT NULL), qr2(item, subgroup) AS (SELECT id, subgroup2 FROM superhero_group WHERE subgroup2 IS NOT NULL) select item, subgroup1, subgroup2, dense_rank() over (order by item) as group from (select qr1.item, qr1.subgroup as subgroup1, qr2.subgroup as subgroup2 from qr1 full outer join qr2 on qr1.item = qr2.item) as combined"], "sol_sql": ["WITH RECURSIVE qr1(item, subgroup) AS (SELECT id, subgroup1 FROM superhero_group WHERE subgroup1 IS NOT NULL), qr2(item, subgroup) AS (SELECT id, subgroup2 FROM superhero_group WHERE subgroup2 IS NOT NULL), qr(item, subgroup) AS (SELECT * FROM qr1 UNION ALL SELECT * FROM qr2), cte(item, other, items) AS (SELECT item, item, ARRAY[item] FROM qr UNION ALL SELECT cte.item, g.item, cte.items || g.item FROM cte JOIN qr ON qr.item = cte.other JOIN qr g ON g.subgroup = qr.subgroup WHERE g.item <> ALL (cte.items)) SELECT item, MIN(qr1.subgroup) AS sg1, MIN(qr2.subgroup) AS sg2, DENSE_RANK() OVER (ORDER BY MIN(other)) AS grp FROM cte LEFT JOIN qr1 USING (item) LEFT JOIN qr2 USING (item) GROUP BY item ORDER BY item;"], "preprocess_sql": ["CREATE TABLE superhero_group (id INTEGER PRIMARY KEY, subgroup1 INTEGER, subgroup2 INTEGER)", "INSERT INTO superhero_group VALUES (1,1,5), (2,1,null), (3,2,null), (4,3,null), (5,3,6), (6,4,6), (7,null,7), (8,null,5), (10,null,5)"], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "551_1", "selected_database": "superhero", "query": "In the superhero database, a user is allowed to view details of a superhero if their user_id matches the superhero's publisher_id or if there is an entry in the 'hero_access' table where their user_id is in the 'read_acl' column (array using gin index). Both tables have about 2 million rows. The query is slow, especially when using an OR clause. Is there a way that improves the performance significantly?", "error_sql": ["select * from superhero where publisher_id = 1 or exists (select * from hero_access f where superhero.id = f.superhero_id and '{1}' && read_acl) order by superhero.id limit 10;"], "sol_sql": ["select * from superhero where publisher_id = 1 union select * from superhero where id in (select superhero_id from hero_access f where '{1}' && read_acl) order by id limit 10;"], "preprocess_sql": ["CREATE TABLE hero_access (superhero_id bigint, read_acl text[]);", "CREATE INDEX idx_hero_access_read_acl ON hero_access USING gin (read_acl);", "INSERT INTO hero_access (superhero_id, read_acl) SELECT id, ARRAY['1'] FROM superhero ORDER BY random() LIMIT 10;"], "clean_up_sql": ["DROP TABLE hero_access;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "], "efficiency": true}
{"instance_id": "552_3", "selected_database": "california_schools", "query": "I am trying to find a solution in PostgreSQL to add an extra column to the output of the query that indicates whether a school has any records in the FRPM table or not. I need to perform the following tasks:\\n1. Join the schools table with the satscores table.\\n2. Add a new column to the result output that checks if the school exists in the FRPM table based on the cdscode.\\nMy tables are:\\n- schools (contains information about schools)\\n- satscores (contains SAT scores for schools)\\n- frpm (contains free and reduced-price meal data for schools)\\nThis is what I have now. I did a left outer join and it works as expected:\\nsql \\nSELECT schools.cdscode, schools.school, satscores.avgscrread, satscores.avgscrmath, satscores.avgscrwrite \\nFROM schools \\nLEFT OUTER JOIN satscores \\nON schools.cdscode = satscores.cds \\nWHERE schools.county = 'Alameda' AND satscores.avgscrread >= 500; \\n\\nwith output:\\n| cdscode        | school                           | avgscrread | avgscrmath | avgscrwrite |\\n|----------------|----------------------------------|------------|------------|-------------|\\n| 01100170109835 | FAME Public Charter                | 525        | 514        | 503         |\\n| 01100170112607 | Envision Academy for Arts & Technology | 550        | 530        | 520         |\\nNow I can't find a solution of how to add an extra column `has_frpm_data` to the query response, where I will check if `schools.cdscode exists in frpm table under cdscode column`.\\nFor example, frpm table can have such data:\\n| cdscode        | Academic Year | County Code | District Code | School Code | County Name | District Name | School Name | District Type | School Type | Educational Option Type | NSLP Provision Status | Charter School (Y/N) | Charter School Number | Charter Funding Type | irc | Low Grade | High Grade | Enrollment (K-12) | Free Meal Count (K-12) | Percent (%) Eligible Free (K-12) | FRPM Count (K-12) | Percent (%) Eligible FRPM (K-12) | Enrollment (Ages 5-17) | Free Meal Count (Ages 5-17) | Percent (%) Eligible Free (Ages 5-17) | FRPM Count (Ages 5-17) | Percent (%) Eligible FRPM (Ages 5-17) | 2013-14 CALPADS Fall 1 Certification Status |\\n| 01100170109835 | 2020-2021     | 0691051     | 109835      | 109835      | Alameda     | Alameda County Office of Education | FAME Public Charter | Unified School District | High Schools (Public) | Traditional             | Provision 3             | 1                    | 0728                | Directly funded        | 1   | 9           | 12          | 1000              | 200                    | 20.0                          | 300               | 30.0                          | 1200                     | 250                         | 21.0                            | 350                      | 35.0                            | 1                                                   |\\n| 01100170112607 | 2020-2021     | 0691051     | 112607      | 112607      | Alameda     | Alameda County Office of Education | Envision Academy for Arts & Technology | Unified School District | High Schools (Public) | Traditional             | Provision 3             | 1                    | 0811                | Directly funded        | 1   | 9           | 12          | 1200              | 250                    | 21.0                          | 350               | 35.0                          | 1400                     | 300                         | 22.0                            | 400                      | 40.0                            | 1                                                   |\\nSo we see that some schools can appear in FRPM data several times (so I'm looking for at least 1 match). And some schools don't have FRPM data at all.\\nOutput finally should be like that:\\n| cdscode        | school                           | avgscrread | avgscrmath | avgscrwrite | has_frpm_data |\\n|----------------|----------------------------------|------------|------------|-------------|---------------|\\n| 01100170109835 | FAME Public Charter                | 525        | 514        | 503         | true          |\\n| 01100170112607 | Envision Academy for Arts & Technology | 550        | 530        | 520         | true          |\\n| 01100170118489 | Another School                   | 510        | 520        | 515         | false         |\\nThanks a lot for any help :)", "error_sql": ["SELECT schools.cdscode, schools.school, satscores.avgscrread, satscores.avgscrmath, satscores.avgscrwrite FROM schools LEFT OUTER JOIN satscores ON schools.cdscode = satscores.cds WHERE schools.county = 'Alameda' AND satscores.avgscrread >= 500"], "sol_sql": ["SELECT schools.cdscode, schools.school, satscores.avgscrread, satscores.avgscrmath, satscores.avgscrwrite, EXISTS (SELECT 1 FROM frpm WHERE frpm.cdscode = schools.cdscode) AS has_frpm_data FROM schools LEFT OUTER JOIN satscores ON schools.cdscode = satscores.cds WHERE schools.county = 'Alameda' AND satscores.avgscrread >= 500"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "553_3", "selected_database": "superhero", "query": "I have two tables and I want to merge them. Table utm is a source-main table and table report contains data for utm rows. What I need: Take id and utm_ from utm table and add stats from table report with proper granulation. In table utm I've a row: (24611609, 'myTarget', 'Media', 'Social', NULL, NULL) and in table report I've 2 rows: \n(24611609, '2022-08-01', 200, 150, 15, 'myTarget', 'Media', 'Social', 'premium', 'subcribe'),\n(24611609, '2022-08-01', 25, 10, 1, 'myTarget', 'Media', 'Social', 'free', 'subcribe')\n Common is: 'myTarget', 'Media', 'Social'.\nProper granularity level is id, utm_campaign, utm_source, utm_medium, so I need to SUM and GROUP two rows by these keys. I don't know how to deal with all possible granularity combinations. My idea was just use diffrent JOINS variations and merge results with UNION. But it's really stupid, I should create > 1000 unions and joins. Any tips?", "error_sql": ["WITH r AS (SELECT id, date_of_visit, SUM(sessions) AS sessions, SUM(pageviews) AS pageviews, SUM(bounces) AS bounce, COALESCE(utm_campaign, '') AS utm_campaign, COALESCE(utm_source, '') AS utm_source, COALESCE(utm_medium, '') AS utm_medium, COALESCE(utm_content, '') AS utm_content, COALESCE(utm_term, '') AS utm_term FROM report GROUP BY id, date_of_visit, utm_campaign, utm_source, utm_medium, utm_content, utm_term UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), COALESCE(utm_campaign, ''), COALESCE(utm_source, ''), '' AS utm_medium, '' AS utm_content, '' AS utm_term FROM report GROUP BY id, date_of_visit, utm_campaign, utm_source UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), COALESCE(utm_campaign, ''), '' AS utm_source, COALESCE(utm_medium, ''), '' AS utm_content, '' AS utm_term FROM report GROUP BY id, date_of_visit, utm_campaign, utm_medium UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), COALESCE(utm_campaign, ''), '' AS utm_source, '' AS utm_medium, COALESCE(utm_content, ''), '' AS utm_term FROM report GROUP BY id, date_of_visit, utm_campaign, utm_content UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), COALESCE(utm_campaign, ''), '' AS utm_source, '' AS utm_medium, '' AS utm_content, COALESCE(utm_term, '') FROM report GROUP BY id, date_of_visit, utm_campaign, utm_term UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), '' AS utm_campaign, COALESCE(utm_source, ''), COALESCE(utm_medium, ''), '' AS utm_content, '' AS utm_term FROM report GROUP BY id, date_of_visit, utm_source, utm_medium UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), '' AS utm_campaign, COALESCE(utm_source, ''), '' AS utm_medium, COALESCE(utm_content, ''), '' AS utm_term FROM report GROUP BY id, date_of_visit, utm_source, utm_content UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), '' AS utm_campaign, COALESCE(utm_source, ''), '' AS utm_medium, '' AS utm_content, COALESCE(utm_term, '') FROM report GROUP BY id, date_of_visit, utm_source, utm_term UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), '' AS utm_campaign, '' AS utm_source, COALESCE(utm_medium, ''), COALESCE(utm_content, ''), '' AS utm_term FROM report GROUP BY id, date_of_visit, utm_medium, utm_content UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), '' AS utm_campaign, '' AS utm_source, COALESCE(utm_medium, ''), '' AS utm_content, COALESCE(utm_term, '') FROM report GROUP BY id, date_of_visit, utm_medium, utm_term UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), '' AS utm_campaign, '' AS utm_source, '' AS utm_medium, COALESCE(utm_content, ''), COALESCE(utm_term, '') FROM report GROUP BY id, date_of_visit, utm_content, utm_term UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), '' AS utm_campaign, '' AS utm_source, '' AS utm_medium, '' AS utm_content, '' AS utm_term FROM report GROUP BY id, date_of_visit) SELECT r.* FROM r JOIN utm AS u ON r.id = u.row_id AND (r.utm_campaign = u.utm_campaign OR (r.utm_campaign = '' AND u.utm_campaign IS NULL)) AND (r.utm_source = u.utm_source OR (r.utm_source = '' AND u.utm_source IS NULL)) AND (r.utm_medium = u.utm_medium OR (r.utm_medium = '' AND u.utm_medium IS NULL)) AND (r.utm_content = u.utm_content OR (r.utm_content = '' AND u.utm_content IS NULL)) AND (r.utm_term = u.utm_term OR (r.utm_term = '' AND u.utm_term IS NULL)) WHERE 'NA' NOT IN (r.utm_campaign, r.utm_source, r.utm_medium, r.utm_content, r.utm_term);"], "sol_sql": ["WITH r AS (SELECT id, date_of_visit, sum(sessions) as sessions, sum(pageviews) as pageviews, sum(bounces) as bounce, coalesce(utm_campaign, '') as utm_campaign, coalesce(utm_source, '') as utm_source, coalesce(utm_medium, '') as utm_medium, coalesce(utm_content, '') as utm_content, coalesce(utm_term, '') as utm_term FROM report as r GROUP BY id, date_of_visit, cube(6, 7, 8, 9, 10)) SELECT r.* FROM r JOIN utm as u ON r.id = u.row_id AND (r.utm_campaign, r.utm_source, r.utm_medium, r.utm_content, r.utm_term) IS NOT DISTINCT FROM (u.utm_campaign, u.utm_source, u.utm_medium, u.utm_content, u.utm_term) WHERE 'NA' IN (r.utm_campaign, r.utm_source, r.utm_medium, r.utm_content, r.utm_term) IS NOT TRUE;"], "preprocess_sql": ["CREATE TABLE utm (row_id int8 NOT NULL, utm_campaign text NULL, utm_source text NULL, utm_medium text NULL, utm_content text NULL, utm_term text NULL);", "INSERT INTO utm (row_id, utm_campaign, utm_source, utm_medium, utm_content, utm_term) VALUES (24611609, 'myTarget', 'Media', 'Social', NULL, NULL), (28573041, 'shop_ smartfony', 'my_beeline', 'banner', NULL, NULL), (28573041, 'Beeline_uppers_2022', NULL, NULL, NULL, NULL), (24611609, 'campaign', 'source', 'medium', 'content', 'term');", "CREATE TABLE report (id int8 NOT NULL, date_of_visit date NOT NULL, sessions numeric NULL, pageviews numeric NULL, bounces numeric NULL, utm_campaign text NULL, utm_source text NULL, utm_medium text NULL, utm_content text NULL, utm_term text NULL);", "INSERT INTO report (id, date_of_visit, sessions, pageviews, bounces, utm_campaign, utm_source, utm_medium, utm_content, utm_term) VALUES (24611609, '2022-08-01', 200, 150, 15, 'myTarget', 'Media', 'Social', 'premium', 'subcribe'), (24611609, '2022-08-01', 25, 10, 1, 'myTarget', 'Media', 'Social', 'free', 'subcribe'), (28573041, '2022-08-01', 900, 885, 34, 'shop_ smartfony', 'my_beeline', 'banner', NULL, NULL), (28573041, '2022-08-01', 1000, 900, 10, 'Beeline_uppers_2022', NULL, NULL, NULL, NULL), (21781121, '2022-08-01', 500, 50, 5, 'vodafone', 'google', NULL, NULL, NULL), (21781121, '2022-08-01', 55, 50, 3, 'vodafone', 'google', 'youtube', NULL, NULL), (24611609, '2022-08-01', 1, 1, 0, 'campaign', 'source', 'medium', 'content', 'term');"], "clean_up_sql": ["DROP TABLE utm;", "DROP TABLE report"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    count = sum('union' in sql.lower() for sql in pred_sqls)\n    result = 0 if count > 3 else 1\n    assert result == 1, f\"Expected 1 because json_object_agg includes redundant aggregations which is not allowed, but got {result}.\"\n    return result"]}
{"instance_id": "368_2", "selected_database": "card_games", "query": "I have a local PostgreSQL database named card_games, with a table called cards that contains many columns. One of these columns is named text, which stores details about each card's abilities or effects. Sometimes, the text field contains one or more curly-brace expressions indicating costs or actions. For example:\n\"{{T}}: Target creature gains haste until end of turn.\"\n\"{{1}}{{W}}: Prevent the next 2 damage that would be dealt to any target.\"\n\"{{2}}{{U}}{{U}}: Draw two cards, then discard a card.\"\n\"Flying  (This creature can't be blocked except by creatures with flying or reach) {{G}}{{1}}\"\n\nI want to extract all the bracketed tokens (i.e., everything in {{...}}) from the text field, potentially returning them in a separate column or combining them into a list. Additionally, some rows may contain multiple occurrences of these curly-brace expressions, separated by normal text.\n\nHow can I write a SQL query (using PostgreSQL features like regexp_matches, substring, or similar) to:\n\t1.\tFind all bracketed tokens within each row's text column,\n\t2.\tReturn them in a format where I can see each token (e.g., {{T}}, {{1}}{{W}}, etc.) separately or as an array,\n\t3.\tHandle rows that have multiple bracketed tokens or none at all,\n\t4.\tOptionally count how many curly-brace expressions appear per row?\n\nI'm specifically looking for a solution that runs purely in SQL (e.g. using regexp_replace, regexp_matches, or other built-in PostgreSQL string functions). How should I structure my query to achieve this? Are there any caveats with capturing multiple matches from the same row in PostgreSQL?", "error_sql": ["SELECT\n    id,\n    text,\n    REGEXP_MATCHES(\n        text,\n        '\\{.*?\\}',\n        'g'\n    ) AS bracketed_tokens\nFROM cards;"], "sol_sql": ["SELECT\n    c.id,\n    c.text,\n    (\n        SELECT array_agg(matches[1])\n        FROM regexp_matches(\n            c.text,\n            '(\\{[^{}]*\\})',\n            'g'\n        ) AS matches\n    ) AS bracketed_tokens\nFROM cards AS c;"], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = pred_query_result == sol_query_result\n    assert result, f\"ex returned {result} but expected True.\"\n    return result"]}
{"instance_id": "554_3", "selected_database": "superhero", "query": "I am porting the queries from InfluxDB to TimescaleDB (PostgreSQL). I am currently stuck with the equivalent of InfluxDB's TOP and BOTTOM functions. Specifically, I need to find the top 5 and bottom 5 races within each gender_id group, ranked by the number of superheroes. If multiple races have the same count, they should share the same rank. In InfluxDB, I would use TOP(count(race_id), 5) in each group with the same gender_id. How can I achieve this in PostgreSQL?", "error_sql": ["SELECT race_id, top(count(*), 5) as cnt FROM superhero group by gender_id"], "sol_sql": ["WITH ranked_races AS (SELECT gender_id, race_id, COUNT(*) AS count, DENSE_RANK() OVER (PARTITION BY gender_id ORDER BY COUNT(*) DESC) AS rank FROM superhero GROUP BY gender_id, race_id) SELECT gender_id, race_id, count FROM ranked_races WHERE rank <= 5;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "555_2", "selected_database": "card_games", "query": "I have this SQL query to get the top 3 rulings for each uuid in the given list: 6d268c95-c176-5766-9a46-c14f739aba1c, 56f4935b-f6c5-59b9-88bf-9bcce20247ce, 8dfc67e9-8323-5d1f-9e25-9f9394abd5a0, 5ac794d2-4c66-5332-afb1-54b24bc11823, 60f49caf-3583-5f85-b4b3-08dca73a8628, ranked by the number of rulings. However, my current query is not working correctly and is not returning the expected results.", "error_sql": ["SELECT rulings.id, rulings.date, rulings.text, rulings.uuid FROM rulings WHERE rulings.uuid IN ('6d268c95-c176-5766-9a46-c14f739aba1c', '56f4935b-f6c5-59b9-88bf-9bcce20247ce', '8dfc67e9-8323-5d1f-9e25-9f9394abd5a0', '5ac794d2-4c66-5332-afb1-54b24bc11823', '60f49caf-3583-5f85-b4b3-08dca73a8628') GROUP BY rulings.id ORDER BY rulings.id LIMIT 3"], "sol_sql": ["SELECT r.* FROM unnest(ARRAY['6d268c95-c176-5766-9a46-c14f739aba1c', '56f4935b-f6c5-59b9-88bf-9bcce20247ce', '8dfc67e9-8323-5d1f-9e25-9f9394abd5a0', '5ac794d2-4c66-5332-afb1-54b24bc11823', '60f49caf-3583-5f85-b4b3-08dca73a8628']::uuid[]) AS p(uuid) CROSS JOIN LATERAL (SELECT id, date, text, uuid FROM rulings r WHERE r.uuid = p.uuid::varchar ORDER BY date DESC LIMIT 3) r ORDER BY uuid, date DESC;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "556_3", "selected_database": "formula_1", "query": "I am analyzing Formula 1 race data to rank drivers based on their total points across multiple races. Each driver earns points for their position in each race. I want to retain the discrete race scoring while also ranking the drivers in the series. For example, considering a sub-query that returns this:\\n| Driver ID | Driver Name | Total Points | Race Points | Race ID |\\n| --------- | ----------- | ------------ | ----------- | ------- |\\n| 1         | Lewis       | 50           | 10          | 101     |\\n| 1         | Lewis       | 50           | 20          | 102     |\\n| 1         | Lewis       | 50           | 20          | 103     |\\n| 2         | Nico        | 40           | 20          | 101     |\\n| 2         | Nico        | 40           | 20          | 102     |\\nYou can see Lewis has 50 points, as he won 10, 20, and 20 points in three races. Nico has 40 points, as he won 20 and 20 points in two races.\\nNow for the ranking, what I'd like is:\\n| Place     | Driver ID | Driver Name | Total Points | Race Points | Race ID |\\n| --------- | --------- | ----------- | ------------ | ----------- | ------- |\\n| 1         | 1         | Lewis       | 50           | 10          | 101     |\\n| 1         | 1         | Lewis       | 50           | 20          | 102     |\\n| 1         | 1         | Lewis       | 50           | 20          | 103     |\\n| 2         | 2         | Nico        | 40           | 20          | 101     |\\n| 2         | 2         | Nico        | 40           | 20          | 102     |\\nBut if I use `rank()` and `order by Total Points`, I get:\\n| Place     | Driver ID | Driver Name | Total Points | Race Points | Race ID |\\n| --------- | --------- | ----------- | ------------ | ----------- | ------- |\\n| 1         | 1         | Lewis       | 50           | 10          | 101     |\\n| 1         | 1         | Lewis       | 50           | 20          | 102     |\\n| 1         | 1         | Lewis       | 50           | 20          | 103     |\\n| 4         | 2         | Nico        | 40           | 20          | 101     |\\n| 4         | 2         | Nico        | 40           | 20          | 102     |\\nWhich makes sense, since there are three 'ties' at 50 points.\\n`dense_rank()` solves this problem, but if there are legitimate ties across different drivers, I want there to be gaps in the rank (e.g if Lewis and Nico both had 50 points, they are both the first place and the next driver would be in third place, no second).\\nThe easiest way to solve this I think would be to issue two queries, one with the 'duplicate' drivers eliminated, and then a second one where I can retain the individual race data, which I need for the points break down display.\\nI can also probably, given enough effort, think of a way to do this in a single query, but I'm wondering if I'm not just missing something really obvious that could accomplish this in a single, relatively simple query.\\nAny suggestions?", "error_sql": ["select rank() over (order by total_points desc) as place, id, name, total_points, race_points, raceId from racers"], "sol_sql": ["WITH riders AS ( SELECT DISTINCT id, name, total_points FROM racers), places AS (SELECT id, name, RANK() OVER (ORDER BY total_points DESC) AS place FROM riders) SELECT p.place, r.*  FROM places p JOIN racers r ON (r.id, r.name) = (p.id, p.name);"], "preprocess_sql": ["CREATE TABLE racers (id integer, name text, total_points integer, race_points integer, raceId integer);", "INSERT INTO racers (id, name, total_points, race_points, raceId) VALUES (1, 'Lewis', 50, 10, 123), (1, 'Lewis', 50, 20, 234), (1, 'Lewis', 50, 20, 345), (2, 'Nico', 40, 20, 123), (2, 'Nico', 40, 20, 234), (3, 'Dave', 50, 30, 123), (3, 'Dave', 50, 20, 234);"], "clean_up_sql": ["DROP TABLE racers;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "557_3", "selected_database": "california_schools", "query": "In the context of the 'california_schools' database, we have three tables: 'schools', 'satscores', and 'frpm'. The 'schools' table contains detailed information about each school, the 'satscores' table contains SAT scores for each school, and the 'frpm' table contains information about the free and reduced-price meal eligibility for each school. We want to determine for each school in the 'satscores' table, whether there is any corresponding entry in the 'frpm' table for the same school. The user has written a query that checks for the existence of such entries but believes it is inefficient as it traverses the 'frpm' table twice. Is there a better way?", "error_sql": ["SELECT s.cds, true FROM satscores s WHERE EXISTS (SELECT 1 FROM frpm f WHERE s.cds = f.cdscode) UNION SELECT s.cds, false FROM satscores s WHERE NOT EXISTS (SELECT 1 FROM frpm f WHERE s.cds = f.cdscode) ORDER BY cds"], "sol_sql": ["SELECT s.cds, s.cds IN (SELECT cdscode FROM frpm) AS frpm_exists FROM satscores s order by cds"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "], "efficiency": true}
{"instance_id": "558_3", "selected_database": "card_games", "query": "In the card_games database, we have a table named 'orders' that records the purchase history of customers. Each entry in the 'orders' table includes the month and year of the purchase, the order ID, and the customer ID. We want to analyze the purchase behavior of our customers to identify repeat customers. A repeat customer is defined as a customer who has made at least one purchase in the past and makes another purchase in a subsequent month. We aim to count the number of repeat customers per month. For example, if a customer made their first purchase in January 2022, then any purchase they make in February 2022 or later should be counted as a repeat purchase in that respective month. The user attempted to write a query to count repeat customers but encountered issues with the query logic, which only counted customers who made more than one purchase in the same month rather than those who made a purchase in a subsequent month after their first purchase.", "error_sql": ["SELECT month_year, COUNT(DISTINCT customer_id) FROM orders GROUP BY month_year HAVING COUNT(order_id) > 1"], "sol_sql": ["WITH first_purchase AS (SELECT customer_id, MIN(month_year) AS first_month FROM orders GROUP BY customer_id) SELECT o.month_year, COUNT(DISTINCT o.customer_id) AS repeat_customers FROM orders o JOIN first_purchase fp ON o.customer_id = fp.customer_id WHERE o.month_year > fp.first_month GROUP BY o.month_year ORDER BY o.month_year;"], "preprocess_sql": ["CREATE TABLE orders (month_year text, order_id text, customer_id bigint);", "INSERT INTO orders (month_year, order_id, customer_id) VALUES ('2016-04', '0001', 24662), ('2016-05', '0002', 24662), ('2016-05', '0002', 24662), ('2016-07', '0003', 24662), ('2016-07', '0003', 24662), ('2016-07', '0004', 24662), ('2016-07', '0004', 24662), ('2016-08', '0005', 24662), ('2016-08', '0006', 24662), ('2016-08', '0007', 24662), ('2016-08', '0008', 24662), ('2016-08', '0009', 24662), ('2016-08', '0010', 11372), ('2016-08', '0011', 11372), ('2016-09', '0012', 24662), ('2016-10', '0013', 24662), ('2016-10', '0014', 11372), ('2016-11', '0015', 24662), ('2016-11', '0016', 11372), ('2016-12', '0017', 11372), ('2017-01', '0018', 11372), ('2017-01', '0019', 11372);"], "clean_up_sql": ["DROP TABLE orders;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "559_1", "selected_database": "european_football_2", "query": "In the database european_football_2, there is a table named player_movements that records the movements of football players joining and leaving teams. Each row in the table includes the player's name, the event (either 'Join' or 'Leave'), and the timestamp of the event. The goal is to transform this data into a format that shows the periods during which each player was part of a team. Specifically, we want to create a table that lists each player, the date they joined a team, and the date they left the team. This will allow us to easily query the data to determine if a player was part of a team on a specific date. For example, we should be able to find out if Player A was on Team X on a given date by using a query like: SELECT * FROM transformed_table WHERE player_name = 'Player A' AND '2022-01-01' BETWEEN joined_date AND left_date. However, the user attempted to write a query that did not produce the desired results.", "error_sql": ["SELECT player_name, event_date as join_date, (SELECT event_date FROM player_movements pm1 WHERE pm1.player_name = pm.player_name AND pm1.event = 'Leave' AND pm1.event_date > pm.event_date) as leave_date FROM player_movements pm WHERE event = 'Join'"], "sol_sql": ["SELECT player_name, event_date AS joined_date, (SELECT MIN(event_date) FROM player_movements pm1 WHERE pm1.player_name = pm.player_name AND pm1.event = 'Leave' AND pm1.event_date > pm.event_date) AS left_date FROM player_movements pm WHERE event = 'Join'"], "preprocess_sql": ["CREATE TABLE player_movements (player_name VARCHAR(100), event VARCHAR(10), event_date DATE);", "INSERT INTO player_movements (player_name, event, event_date) VALUES ('Player A', 'Join', '2022-01-01'), ('Player A', 'Leave', '2022-01-02'), ('Player A', 'Join', '2022-01-31'), ('Player A', 'Leave', '2022-02-01'), ('Player B', 'Join', '2022-01-31'), ('Player B', 'Leave', '2022-02-01');"], "clean_up_sql": ["DROP TABLE player_movements;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "438_1", "selected_database": "european_football_2", "query": "We have a table named 'player_attributes' that records various performance metrics for players. Each record includes the following metrics: gk_diving, gk_handling, gk_kicking, gk_positioning, gk_reflexes. For example, if a player has gk_diving = 6, gk_handling = 10, gk_kicking = 11, gk_positioning = 8, gk_reflexes = 8, the average after removing the highest (11) and lowest (6) amounts would be (8 + 8 + 10) / 3 = 8.6667. The following is the method I use. It is very bloated and the execution time is too long. Is there a neat way to achieve my needs?", "error_sql": ["SELECT id, (SUM(gk) - MAX(gk) - MIN(gk)) / (COUNT(gk) - 2) AS adjusted_average FROM (SELECT id, gk_diving AS gk FROM player_attributes UNION ALL SELECT id, gk_handling AS gk FROM player_attributes UNION ALL SELECT id, gk_kicking AS gk FROM player_attributes UNION ALL SELECT id, gk_positioning AS gk FROM player_attributes UNION ALL SELECT id, gk_reflexes AS gk FROM player_attributes) subquery GROUP BY id ORDER BY id;"], "sol_sql": ["SELECT id, ((gk_diving + gk_handling + gk_kicking + gk_positioning + gk_reflexes) - GREATEST(gk_diving, gk_handling, gk_kicking, gk_positioning, gk_reflexes) - LEAST(gk_diving, gk_handling, gk_kicking, gk_positioning, gk_reflexes)) / 3.0 AS adjusted_average FROM player_attributes ORDER BY id;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "], "efficiency": true}
{"instance_id": "443_1", "selected_database": "financial", "query": "In the financial database, there is a table named 'trans' which records all transactions made by clients. Each transaction has a unique transaction ID, the account ID associated with the transaction, the date of the transaction, the type of transaction (credit or debit), the operation performed, the amount involved, the balance after the transaction, and additional details such as the bank and account of the partner. The table has more than 1000000 rows and is growing rapidly. I need to extract the most recent transaction (based on the transaction date) for each account ID. I also tried to avoid using a subquery but did not notice a significant difference. Any idea how I could optimize this query?", "error_sql": ["DROP INDEX IF EXISTS idx_a;", "SELECT DISTINCT ON (t.account_id) t.trans_id, t.account_id, t.date, t.type, t.amount, t.balance FROM trans t ORDER BY t.account_id, t.date DESC, trans_id;"], "sol_sql": ["CREATE INDEX idx_a ON trans (account_id, date DESC, trans_id);", "SELECT DISTINCT ON (t.account_id) t.trans_id, t.account_id, t.date, t.type, t.amount, t.balance FROM trans t;"], "preprocess_sql": [], "clean_up_sql": ["DROP INDEX IF EXISTS idx_a;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "], "efficiency": true}
{"instance_id": "269_1", "selected_database": "financial", "query": "A financial analyst is tasked with analyzing transaction data to summarize daily financial activities for each client.     They need to calculate the total amount of transactions, total balance changes, and the number of transactions for each client,     partitioned by date. The analyst writes a query using the same window function with the same partition definition for multiple result columns     but encounters redundancy. The use wants to use one PARTITION definition for multiple window function calls.", "error_sql": ["\n        select account_id, date, \n        sum(amount) OVER (PARTITION BY account_id, date) as total_amount, \n        sum(balance) OVER (PARTITION BY account_id, date) as total_balance, \n        count(trans_id) OVER (PARTITION BY account_id, date) as total_transactions\n        from trans \n        "], "sol_sql": ["\n        select account_id, date, \n        sum(amount) OVER w as total_amount, \n        sum(balance) OVER w as total_balance, \n        count(trans_id) OVER w as total_transactions\n        from trans WINDOW w AS (PARTITION BY account_id, date);\n        "], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    \n    lower_sqls = ' '.join(pred_sqls)\n    lower_sqls = lower_sqls.lower()\n    keyword_count = lower_sqls.count('partition by')\n    assert keyword_count == 1, f\"You need to just use one PARTITION definition.\"\n    "]}
{"instance_id": "272_1", "selected_database": "debit_card_specializing", "query": "I need to retrieve transactions from the `transactions_1k` table based on     a lexicographic ordering on multiple columns, where the direction of the sort on some     columns is reversed. Specifically, I want to find transactions that occurred before     a certain date, or on the same date but after a certain time, or on the same date and time     but with a transaction amount less than a specified value. For example, I want to find     transactions that occurred before '2012-08-24', or on '2012-08-24' but after '10:00:00',     or on '2012-08-24' at '10:00:00' but with an amount less than 20.     Is there a straightforward way to do this using tuples or a similar approach in PostgreSQL?     Note that I cannot rely on tricks that apply only to integers, as some columns are of type date and text.", "error_sql": ["\n        SELECT * FROM transactions_1k WHERE (Date, Time, Amount) < ('2012-08-24', '10:00:00', 20);\n        "], "sol_sql": ["\n        SELECT * FROM transactions_1k WHERE Date < '2012-08-24' OR (Date = '2012-08-24' AND Time > '10:00:00') OR (Date = '2012-08-24' AND Time = '10:00:00' AND Amount < 20);\n        "], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "334_1", "selected_database": "financial", "query": "A financial analyst is trying to generate a report that includes the client's name, the loan details, and the account details for loans that were issued in the year 1996. The analyst has written a query to join the `client`, `disp`, `account`, and `loan` tables. However, the query is failing with an error related to a missing FROM-clause entry.     The analyst needs to retrieve the client's name, loan amount, loan duration, and account creation date for loans issued in 1996.", "error_sql": ["\n        SELECT client.gender, loan.amount, loan.duration, account.date FROM loan JOIN account ON loan.account_id = account.account_id JOIN client ON disp.client_id = client.client_id JOIN disp ON account.account_id = disp.account_id WHERE loan.date BETWEEN '1996-01-01' AND '1996-12-31';\n        "], "sol_sql": ["\n        SELECT client.gender, loan.amount, loan.duration, account.date FROM loan JOIN account ON loan.account_id = account.account_id JOIN disp ON account.account_id = disp.account_id JOIN client ON disp.client_id = client.client_id WHERE loan.date BETWEEN '1996-01-01' AND '1996-12-31';\n        "], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"instance_id": "435_3", "selected_database": "codebase_community", "query": "We are analyzing user engagement with posts on a community forum. Specifically, we want to determine if a user's view of a post had a significant impact based on the duration of the view and the percentage of the post viewed. The 'has_impact' field should be set to true if the difference between the view end time and the view start time is greater than 3 seconds and the view percentage is greater than 0.8, otherwise it should be false. We have a table 'view_logs' that logs each view event with the session_id, post_id, timestamp (ts), event_name (either 'view_start' or 'view_end'), and view percentage (view_perc). We need to populate the 'has_impact' field based on these criteria.", "error_sql": ["with cte as (select pv1.session_id, pv1.post_id, pv2.view_perc, pv1.ts as start_time, min(pv2.ts) as end_time from view_logs pv1 join view_logs pv2 on pv1.session_id = pv2.session_id and pv1.post_id = pv2.post_id and pv1.event_name <> pv2.event_name and pv1.ts < pv2.ts group by pv1.session_id, pv1.post_id, pv2.view_perc, pv1.ts) select session_id, post_id, start_time, end_time, case when (end_time - start_time > 3  and view_perc > 0.8 )then 'yes' else 'no' end as has_meaningful_view from cte;"], "sol_sql": ["select session_id, post_id, max(case when event_name='view_start' then ts end) start_time, max(case when event_name='view_end' then ts end) end_time, case when max(case when event_name='view_end' then ts end) - max(case when event_name='view_start' then ts end) > 3 and max(view_perc) > 0.8 then 'yes' else 'no' end as has_impact from (select *, row_number() over (partition by session_id, post_id order by ts) rn from view_logs) t group by session_id, post_id, (rn-1)/ 2 order by session_id, post_id, min(ts);"], "preprocess_sql": ["create table view_logs (session_id varchar(10), post_id int, ts int, event_name varchar(50), view_perc float);", "insert into view_logs(session_id, post_id, ts, event_name, view_perc) values ('m1', 1000, 1524600, 'view_start', null), ('m1', 1000, 1524602, 'view_end', 0.85), ('m1', 1000, 1524650, 'view_start', null), ('m1', 1000, 1524654, 'view_end', 0.9), ('m1', 2000, 1524700, 'view_start', null), ('m1', 2000, 1524707, 'view_end', 0.3), ('m1', 2000, 1524710, 'view_start', null), ('m1', 2000, 1524713, 'view_end', 0.9);"], "clean_up_sql": ["DROP TABLE IF EXISTS view_logs;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"instance_id": "570_1", "selected_database": "superhero", "query": "In the superhero database, is it possible to return a value from a DELETE statement in PostgreSQL when no rows were deleted? For example, if we attempt to delete a superhero with an ID that does not exist, we want to return a default value indicating that no rows were deleted. We tried using the RETURNING clause with a constant value, but it returned NULL instead of the desired default value.", "error_sql": ["delete from superhero where id = 999 returning 1"], "sol_sql": ["WITH deleted_rows AS (DELETE FROM superhero WHERE id = 999 RETURNING 1) SELECT COALESCE((SELECT * FROM deleted_rows), 0)"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_sqls_result) == 1, f'Expected 1 row, but found {len(pred_sqls_result)} rows'"]}
{"instance_id": "571_1", "selected_database": "superhero", "query": "A data analyst is working with the superhero database and needs to perform a forward fill operation on the 'height_cm' and 'weight_kg' columns of the 'superhero' table. The analyst wants to create a PL/pgSQL function that mimics the behavior of the pandas 'ffill' function, which fills missing values with the last known non-null value. Here we use a table example(row_num int, id int, str text, val int) to test the functionality. We need to get the result of ffill(column val). The analyst has attempted to create a function but encountered syntax errors and incorrect results. The analyst needs a function that can handle forward filling for any specified column in the 'superhero' table, ordered by the 'id' column and partitioned by the 'publisher_id'.", "error_sql": ["CREATE OR REPLACE FUNCTION GapFillInternal(s anyelement, v anyelement) RETURNS anyelement AS $$ DECLARE temp alias for $0; BEGIN RAISE NOTICE 's= %, v= %', s, v; IF v IS NULL AND s NOTNULL THEN temp := s; ELSIF s IS NULL AND v NOTNULL THEN temp := v; ELSIF s NOTNULL AND v NOTNULL THEN temp := v; ELSE temp := NULL; END IF; RAISE NOTICE 'temp= %', temp; RETURN temp; END; $$ LANGUAGE PLPGSQL;", "CREATE AGGREGATE GapFill(anyelement) (SFUNC=GapFillInternal, STYPE=anyelement);", "SELECT id, str, val, GapFill(val) OVER (ORDER BY id) AS valx FROM example;"], "sol_sql": ["CREATE OR REPLACE FUNCTION GapFillInternal(s anyelement, v anyelement) RETURNS anyelement LANGUAGE plpgsql AS $$ BEGIN IF s IS NULL AND v IS NULL THEN RETURN NULL; ELSIF v IS NULL THEN RETURN s; ELSE RETURN v; END IF; END; $$;", "CREATE AGGREGATE GapFill(anyelement) (SFUNC=GapFillInternal, STYPE=anyelement);", "SELECT id, str, val, GapFill(val) OVER (ORDER BY id ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS valx FROM example;;"], "preprocess_sql": ["CREATE TEMPORARY TABLE example(id int, str text, val integer);", "INSERT INTO example VALUES (1, 'a', NULL), (1, NULL, 1), (2, 'b', 2), (2, NULL, NULL)"], "clean_up_sql": ["DROP TABLE IF EXISTS example;", "DROP FUNCTION IF EXISTS GapFillInternal(anyelement, anyelement);", "DROP AGGREGATE IF EXISTS GapFill(anyelement);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "572_1", "selected_database": "california_schools", "query": "In the context of the 'california_schools' database, we need to update the 'table_A' table to deactivate certain items based on their associated records in table 'table_B'. Specifically, we want to find all items in table_A whose associated record in table_B has the 'deleted' set to 'true'. From this set of results, we need to get the 'parent_id' of these items. Then, for any item in the 'table_A' table whose 'id' is part of the 'parent_id' column from the previous result set, we need to check if their 'is_active' is 'true' and if so, make it 'false'. This operation is intended to deactivate items that are part of deleted status but the query gets stuck loading endlessly.", "error_sql": ["UPDATE table_A A SET is_active = false FROM table_A WHERE A.parent_id IS NULL AND A.is_active = true AND A.id = ANY (SELECT (B.parent_id) FROM table_A B INNER JOIN table_B ON table_A.foreign_id = table_B.id WHERE table_B.deleted = true) RETURNING *;"], "sol_sql": ["UPDATE table_A SET is_active = false WHERE parent_id IS NULL AND is_active = true AND id = ANY (SELECT a2.parent_id FROM table_A a2 JOIN table_B b ON a2.foreign_id = b.id WHERE b.deleted = true) RETURNING *"], "preprocess_sql": ["create table table_B (id int primary key, deleted boolean);", "create table table_A (id serial primary key, parent_id int, is_active boolean default true, foreign_id int, foreign key (foreign_id) references table_B(id));", "insert into table_B (id, deleted) values (1, false), (2, true), (5, true), (3, false), (4, false)", "insert into table_A (parent_id, foreign_id) values (null, 1), (1, 2), (1, 5), (null, 3), (3, 4)"], "clean_up_sql": ["DROP TABLE table_A;", "DROP TABLE table_B;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n"], "efficiency": true}
{"instance_id": "573_2", "selected_database": "toxicology", "query": "We are analyzing the sales data of a chemical supply company stored in the 'transactions' table. The columns are id (customer id), amount (amount spent by customer), and timestamp (time of purchase). Assume that today is '2022-01-27'. We need to query:\\n- Yesterday's revenue: sum of amount.\\n- Percent difference from 8 days ago's revenue to yesterday's revenue.\\n- Month-to-date (MTD) revenue.\\n- Percent difference from last month's MTD to this month's MTD.\\nWhen calculating the percentage, round the result to two decimal places.\nGiven the sample data:\\n| id | amount | timestamp |\\n| -- | ------ | --------  |\\n| 1  | 50     | 2021-12-01|\\n| 2  | 60     | 2021-12-02|\\n| 3  | 70     | 2021-11-05|\\n| 4  | 80     | 2022-01-26|\\n| 5  | 90     | 2022-01-25|\\n| 6  | 20     | 2022-01-26|\\n| 7  | 80     | 2022-01-19|\\nThe expected output is:\\n| yesterday_revenue | pct_change_week_ago | mtd | pct_change_month_prior|\\n| -------- | -------------- | --- | --- |\\n| 100   | 0.25          | 270 | 0.50|\\nHowever, the user's query resulted in incorrect percent change columns. Here is the problematic SQL statement:", "error_sql": ["SELECT SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 1 THEN amount ELSE NULL END) AS yesterday_revenue, ROUND((SUM(CASE WHEN timestamp::date > '2022-01-27'::date - 1 THEN amount ELSE NULL END) - SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 8 THEN amount ELSE NULL END)) / SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 8 THEN amount ELSE NULL END), 2) AS pct_change_week_ago, SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) THEN amount ELSE NULL END) AS mtd, ROUND((SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) THEN amount ELSE NULL END) - SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) - interval '1 month' AND date_part('day', timestamp) <= date_part('day', '2022-01-27'::date - 1) THEN amount ELSE NULL END)) / SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) - interval '1 month' AND date_part('day', timestamp) <= date_part('day', '2022-01-27'::date - 1) THEN amount ELSE NULL END), 2) AS pct_change_month_prior FROM transactions;"], "sol_sql": ["SELECT SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 1 THEN amount ELSE NULL END) AS yesterday_revenue, ROUND((SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 1 THEN amount ELSE NULL END) - SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 8 THEN amount ELSE NULL END)) / NULLIF(SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 8 THEN amount ELSE NULL END), 0), 2) AS pct_change_week_ago, SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) THEN amount ELSE NULL END) AS mtd, ROUND((SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) THEN amount ELSE NULL END) - SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) - interval '1 month' AND date_part('day', timestamp) <= date_part('day', '2022-01-27'::date - 1) THEN amount ELSE NULL END)) / NULLIF(SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) - interval '1 month' AND date_part('day', timestamp) <= date_part('day', '2022-01-27'::date - 1) THEN amount ELSE NULL END), 0), 2) AS pct_change_month_prior FROM transactions;"], "preprocess_sql": ["CREATE TABLE transactions (id int, amount numeric, timestamp date);", "INSERT INTO transactions (id, amount, timestamp) VALUES (1, 50, '2021-12-01'), (2, 60, '2021-12-02'), (3, 70, '2021-11-05'), (4, 80, '2022-01-26'), (5, 90, '2022-01-25'), (6, 20, '2022-01-26'), (7, 80, '2022-01-19');"], "clean_up_sql": ["DROP TABLE transactions;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # results = execute_queries(['SELECT * FROM transactions;'], db_name, conn)[0]\n    # assert 1== 0, f'{results}'\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "574_1", "selected_database": "card_games", "query": "I am analyzing the average converted mana cost of cards over a rolling window of 8 previous cards for each card in the 'cards' table. I need to round the nine_day_avg to two decimal places. However, I am having trouble placing the ROUND function correctly in the query. The query below does not produce the desired result. Can you help me correct it?", "error_sql": ["SELECT name, convertedManaCost, avg(convertedManaCost) OVER(ORDER BY id ROWS BETWEEN 8 PRECEDING AND CURRENT ROW) AS nine_card_avg FROM cards WHERE name LIKE 'A%' ORDER BY id DESC"], "sol_sql": ["SELECT name, convertedManaCost, ROUND(avg(convertedManaCost::numeric) OVER(ORDER BY id ROWS BETWEEN 8 PRECEDING AND CURRENT ROW), 2) AS nine_card_avg FROM cards WHERE name LIKE 'A%' ORDER BY id DESC"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "575_1", "selected_database": "superhero", "query": "In the superhero database, each superhero has a set of attributes stored in a B column named 'attributes' within the 'hero_attribute' table. Each attribute object contains an 'ss_id' and an 'approved' status indicating whether the attribute is officially recognized by the superhero community. For example, a single record might look like this:\\n{\\", "error_sql": ["SELECT hero_id, attribute_id, jsonb_array_length(a.ss) AS ss_cnt, jsonb_array_length(CASE WHEN a.ss -> 'approved' = 'true' THEN a.ss END) AS approved_cnt FROM hero_attribute a WHERE a.hero_id IN (1, 2);"], "sol_sql": ["WITH approved_counts AS (SELECT hero_id, attribute_id, COUNT(CASE WHEN (value->>'approved')::boolean THEN 1 END) AS approved_cnt FROM hero_attribute a CROSS JOIN LATERAL jsonb_array_elements(a.ss) AS value GROUP BY hero_id, attribute_id) SELECT a.hero_id, a.attribute_id, jsonb_array_length(a.ss) AS ss_cnt, ac.approved_cnt FROM hero_attribute a JOIN approved_counts ac ON a.hero_id = ac.hero_id AND a.attribute_id = ac.attribute_id;"], "preprocess_sql": ["ALTER TABLE hero_attribute ADD COLUMN ss JSONB;", "UPDATE hero_attribute SET ss = '[{\"ss_id\": 1, \"approved\": true}, {\"ss_id\": 2, \"approved\": false}]' WHERE hero_id = 1;", "UPDATE hero_attribute SET ss = '[{\"ss_id\": 1, \"approved\": true}, {\"ss_id\": 2, \"approved\": true}]' WHERE hero_id = 2;"], "clean_up_sql": ["ALTER TABLE hero_attribute DROP COLUMN ss;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "400_1", "selected_database": "financial", "query": "I am trying to speed up a PostgreSQL query to find previous transactions on the same day of the year from the 'trans' table. My current query is as follows:\\nsql \\nselect * from trans \\nwhere date_part('month', date) = date_part('month', now()) \\nand date_part('day', date) = date_part('day', now()) \\norder by date desc; \\n\\nThis query works but is running much slower than desired. Is there a better approach for comparing the current month and day?\\nThe data is time-series in nature, and I am using PostgreSQL as the database. Here is the current definition of the 'trans' table:\\nsql \\nCREATE TABLE public.trans ( \\n    trans_id int NOT NULL DEFAULT '0', \\n    account_id int NOT NULL DEFAULT '0', \\n    date date NOT NULL, \\n    type text NOT NULL, \\n    operation text, \\n    amount int NOT NULL, \\n    balance int NOT NULL, \\n    k_symbol text, \\\\", "error_sql": ["select * from trans where date_part('month', \"date\") = date_part('month', now()) and date_part('day', \"date\") = date_part('day', now()) order by \"date\" desc;"], "sol_sql": ["SELECT * FROM trans WHERE EXTRACT(MONTH FROM date) = EXTRACT(MONTH FROM CURRENT_DATE) AND EXTRACT(DAY FROM date) = EXTRACT(DAY FROM CURRENT_DATE) ORDER BY date DESC;"], "preprocess_sql": ["CREATE INDEX ix1 ON trans (EXTRACT(MONTH FROM date), EXTRACT(DAY FROM date));"], "clean_up_sql": ["drop index if exists ix1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n    "], "efficiency": true}
{"instance_id": "407_1", "selected_database": "financial", "query": "Is there an efficient way to aggregate data from a jsonb column in postgresql? Given the table userdata(id STRING, data JSONB) and the data in the table named \"test\".As you notice, I want unique values of keys (for e.g. \"dis\") across all records indexed by the id.I tried getting values using jsonb_agg and jsonb_array_elements. I could not aggregate all keys and distinct values. I couldn't figure out how to use jsonb_each to get all keys. What I tried is something like this to get one key. Any help with the query is appreciated. ", "error_sql": ["\nselect id,\n       (select jsonb_agg(t->>'dis') from jsonb_array_elements(data::jsonb) as x(t) where t->>'dis' is not null) as sdata\nfrom test where id='123.abc'\n"], "sol_sql": ["\nselect\n  data.id,\n  jsonb_object_agg(data.key, case when data.key = 'dis' then data.value else data.value->0 end) as final_json\nfrom (\n    select\n      mt.id,\n      props.key,\n      jsonb_agg(distinct coalesce(j.dis, props.value)) as value\n    from test as mt\n    cross join jsonb_each(mt.data) as props\n    left join jsonb_array_elements(case when props.key = 'dis' then props.value end) as j(dis) on 1=1\n    group by\n      mt.id,\n      props.key\n) data\ngroup by\n  data.id;\n"], "preprocess_sql": ["\nCREATE TABLE test (\n    id TEXT NOT NULL,\n    data JSONB NOT NULL\n);\nINSERT INTO test (id, data)\nVALUES\n    ('123.abc', '{\"dis\": [\"close\"]}'),\n    ('123.abc', '{\"purpose\": {\"score\": 0.1, \"text\": \"hi\"}, \"dis\": [\"hello\", \"close\"]}'),\n    ('123.abc', '{\"dis\": [\"bye\"], \"dir\": 1}'),\n    ('123.abc', '{}'),\n    ('567.bhy', '{\"dis\": [\"close\"]}');\n"], "clean_up_sql": ["DROP TABLE test;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[0][1]\n    assert isinstance(concatenated_json, dict), f'Expected result to be a dictionary, but found {type(concatenated_json)}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[0][1]\n    expected_values = {\n        \"dir\": 1,\n        \"dis\": [\"bye\", \"close\", \"hello\"],\n        \"purpose\": {\"text\": \"hi\", \"score\": 0.1}\n    }\n\n    assert concatenated_json == expected_values, f'Expected {expected_values} but found {concatenated_json}'\n    "], "external_data": "('123.abc', '{\"dis\": [\"close\"]}'), ('123.abc', '{\"purpose\": {\"score\": 0.1, \"text\": \"hi\"}, \"dis\": [\"hello\", \"close\"]}'), ('123.abc', '{\"dis\": [\"bye\"], \"dir\": 1}'), ('123.abc', '{}'), ('567.bhy', '{\"dis\": [\"close\"]}')"}
{"instance_id": "590_1", "selected_database": "european_football_2", "query": "\nIn the context of managing a football database, I am trying to update the 'overall_rating' of players based on their 'player_api_id' and the 'date' of their attributes. I have arrays of 'player_api_id's, 'date's, and 'overall_rating's that I want to use to update the 'Player_Attributes' table. My initial approach was to use a loop to iterate through the arrays and update each player's 'overall_rating' individually, but this method incorrectly updates the 'overall_rating' to the last value in the array for all selected players. To fix this issue, I need to ensure that each 'overall_rating' is correctly matched with the corresponding 'player_api_id' and 'date'. One solution is to use the 'unnest' function in SQL to pair the arrays together and update each player's 'overall_rating' individually. Here's the corrected SQL query I plan to use:\n", "error_sql": ["DO $$ DECLARE i integer; BEGIN \n        FOREACH i IN ARRAY[11, 20]::integer[] LOOP \n            RAISE NOTICE 'Value: %', i; \n            UPDATE Player_Attributes SET overall_rating = i \n            WHERE player_api_id = ANY (ARRAY[505942, 155782]::integer[]) \n            AND date = ANY (ARRAY['2016-02-18 00:00:00', '2015-10-16 00:00:00']::text[]);\n        END LOOP; \n    END $$;"], "sol_sql": ["\n    DO $$ \n    DECLARE \n        i integer; \n        j integer; \n        k text; \n    BEGIN \n        FOR i, j, k IN \n            SELECT unnest(ARRAY[11, 20]::integer[]), \n                   unnest(ARRAY[505942, 155782]::integer[]), \n                   unnest(ARRAY['2016-02-18 00:00:00', '2015-10-16 00:00:00']::text[])\n        LOOP \n            UPDATE Player_Attributes \n            SET overall_rating = i \n            WHERE player_api_id = j \n            AND date = k; \n        END LOOP; \n    END $$;\n    "], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(\n        [\"SELECT * FROM Player_Attributes WHERE player_api_id = 505942 AND date = '2016-02-18 00:00:00';\"], \n        'european_football_2', conn\n    )[0]\n    \n    test_pred_query_result_2 = execute_queries(\n        [\"SELECT * FROM Player_Attributes WHERE player_api_id = 155782 AND date = '2015-10-16 00:00:00';\"], \n        'european_football_2', conn\n    )[0]\n    \n    assert len(test_pred_query_result_1) == 1, 'There should be exactly one record for player_api_id = 505942 and date = 2016-02-18.'\n    assert test_pred_query_result_1[0][4] == 11, 'Player 505942 overall_rating should be updated to 11.'\n    \n    assert len(test_pred_query_result_2) == 1, 'There should be exactly one record for player_api_id = 155782 and date = 2015-10-16.'\n    assert test_pred_query_result_2[0][4] == 20, 'Player 155782 overall_rating should be updated to 20.'\n"]}
{"instance_id": "594_1", "selected_database": "formula_1", "query": "In the context of the Formula 1 database, I am trying to perform a full-text search on a specific B field within the 'results' table. The B field contains race result details, and I am particularly interested in searching within the 'fastestLapTime' attribute. My initial attempt to perform this search using the `to_tsvector` and `to_tsquery` functions did not yield the expected results. Here is the problematic SQL statement I used:", "error_sql": ["\nSELECT resultId FROM results WHERE to_tsvector(results.fastestLapTime) @@ to_tsquery('1:35.405');\n"], "sol_sql": ["\nSELECT resultId FROM results WHERE fastestLapTime = '1:35.405';\n"], "preprocess_sql": "", "clean_up_sql": "", "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT resultId FROM results WHERE fastestLapTime = '1:35.405';\"], 'formula_1', conn)[0]\n    assert len(test_pred_query_result_1) > 0, 'Expected at least one result with fastestLapTime = 1:35.405, but found none.'\n    assert all(row[0] is not None for row in test_pred_query_result_1), 'Expected all resultIds to be valid, but found NULL values.'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_2 = execute_queries([\"SELECT resultId FROM results WHERE fastestLapTime = '1:35.405';\"], 'formula_1', conn)[0]\n    assert len(test_pred_query_result_2) == 1, f'Expected exactly 1 result with fastestLapTime = 1:35.405, but found {len(test_pred_query_result_2)} results.'\n    assert test_pred_query_result_2[0][0] == 23, f'Expected resultId to be 23, but found {test_pred_query_result_2[0][0]}.'\n"]}
{"instance_id": "592_1", "selected_database": "formula_1", "query": "In the context of Formula 1 racing data, I have a table that records the results of races, including the race ID, driver ID, constructor ID, and the position each driver finished in. I want to count the occurrences of each finishing position by race and insert the number of occurrences into another table as a B object. The positions are not limited to a predefined set and can vary widely. Here's an example of what I'm trying to achieve: For each race, I want to count how many drivers finished in each position and store this information in a B column, where the key is the position and the value is the count of drivers who finished in that position.", "error_sql": ["\nSELECT raceId, position, COUNT(*) as cnt FROM results GROUP BY raceId, position\n"], "sol_sql": ["\nSELECT raceId,\n       jsonb_object_agg(COALESCE(position::text, 'Unknown') , COALESCE(cnt::text, '0')) AS json_count\nFROM (\n    SELECT raceId,\n           position,\n           COUNT(*) AS cnt\n    FROM results\n    GROUP BY raceId, position\n) AS aggregated_counts\nGROUP BY raceId\n"], "preprocess_sql": "", "clean_up_sql": "", "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT COUNT(*) AS total FROM results WHERE raceId = 19 AND position = 1;\"], 'formula_1', conn)[0]\n    assert test_pred_query_result_1[0][0] == 1, f'Expected count of position 1 in race 19 to be 1, but found {test_pred_query_result_1[0][0]}'\n    test_pred_query_result_2 = execute_queries([\"SELECT COUNT(*) AS total FROM results WHERE raceId = 19 AND position = 2;\"], 'formula_1', conn)[0]\n    assert test_pred_query_result_2[0][0] == 1, f'Expected count of position 2 in race 19 to be 1, but found {test_pred_query_result_2[0][0]}'\n    test_pred_query_result_3 = execute_queries([\"SELECT COUNT(*) AS total FROM results WHERE raceId = 19 AND position = 3;\"], 'formula_1', conn)[0]\n    assert test_pred_query_result_3[0][0] == 1, f'Expected count of position 3 in race 19 to be 1, but found {test_pred_query_result_3[0][0]}'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) > 0, 'Expected at least one row in the result, but found none.'\n    assert isinstance(pred_query_result[0][1], dict), 'Expected json_count to be a dictionary, but found something else.'\n    assert '1' in pred_query_result[0][1], 'Expected position 1 to be included in the json_count for raceId 1.'\n"]}
{"instance_id": "595_1", "selected_database": "european_football_2", "query": "In the context of the european_football_2 database, I am trying to understand 'keyset pagination' using the `Match` table which includes `id`, `date`, and `match_api_id` columns. My base query for the first page works perfectly, but I have a few use-cases which I don't understand how does it work if I want to order by `match_api_id DESC`.", "error_sql": ["\nSELECT * FROM Match WHERE (match_api_id, date, id) > (492473, '2008-08-17 00:00:00', 1) ORDER BY date, id ASC LIMIT 3\n"], "sol_sql": ["\nSELECT * FROM Match WHERE (match_api_id, date, id) < (492473, '2008-08-17 00:00:00', 1) ORDER BY match_api_id DESC, date DESC, id DESC LIMIT 3;\n"], "preprocess_sql": "", "clean_up_sql": "", "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the prediction query\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) == 3, f'Expected 3 rows, but found {len(test_pred_query_result_1)} rows'\n    assert test_pred_query_result_1[0][0] == 19855, f'Expected match_api_id to be 19855, but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[1][0] == 19854, f'Expected match_api_id to be 19854, but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[2][0] == 19853, f'Expected match_api_id to be 19853, but found {test_pred_query_result_1[0][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the solution query\n    test_sol_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result_1) == 3, f'Expected 3 rows, but found {len(test_sol_query_result_1)} rows'\n    assert test_sol_query_result_1[0][0] == 19855, f'Expected match_api_id to be 19855, but found {test_sol_query_result_1[0][0]}'\n    assert test_sol_query_result_1[1][0] == 19854, f'Expected match_api_id to be 19854, but found {test_sol_query_result_1[0][0]}'\n    assert test_sol_query_result_1[2][0] == 19853, f'Expected match_api_id to be 19853, but found {test_sol_query_result_1[0][0]}'\n    "]}
{"instance_id": "596_1", "selected_database": "california_schools", "query": "In the context of analyzing school data within the 'california_schools' database, I need to identify all schools that are located in both Alameda and Contra Costa counties. This is similar to finding products whose companies include both A and B in the original problem. I attempted to write a query that would return schools located in more than one county, but I'm struggling to refine this query to specifically include only those schools that are present in both Alameda and Contra Costa counties.", "error_sql": ["\nSELECT School FROM schools GROUP BY School HAVING COUNT(*) > 1 ORDER BY COUNT(*) DESC;\n"], "sol_sql": ["\nSELECT s.School FROM schools s WHERE s.County IN ('Alameda', 'Contra Costa') \nGROUP BY s.School HAVING COUNT(DISTINCT s.County) = 2;\n"], "preprocess_sql": "", "clean_up_sql": "", "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the prediction query\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) > 0, f'Expected to have rows, but found none'\n    assert test_pred_query_result_1[0][0] == 'Alvarado Elementary', f'Expected first school to be \"Alvarado Elementary\", but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[1][0] == 'Bella Vista Elementary', f'Expected second school to be \"Bella Vista Elementary\", but found {test_pred_query_result_1[1][0]}'\n    assert test_pred_query_result_1[2][0] == 'Bidwell Elementary', f'Expected third school to be \"Bidwell Elementary\", but found {test_pred_query_result_1[2][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Execute the solution query\n    test_sol_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result_1) > 0, f'Expected to have rows, but found none'\n    assert test_sol_query_result_1[0][0] == 'Alvarado Elementary', f'Expected first school to be \"Alvarado Elementary\", but found {test_sol_query_result_1[0][0]}'\n    assert test_sol_query_result_1[1][0] == 'Bella Vista Elementary', f'Expected second school to be \"Bella Vista Elementary\", but found {test_sol_query_result_1[1][0]}'\n    assert test_sol_query_result_1[2][0] == 'Bidwell Elementary', f'Expected third school to be \"Bidwell Elementary\", but found {test_sol_query_result_1[2][0]}'\n    "]}
{"instance_id": "526_2", "selected_database": "formula_1", "query": "\nI'm new to SQL & I'm trying to get the raceid and name for each name with the latest date.\n", "error_sql": ["SELECT MAX(date), raceid, name FROM races GROUP BY name, raceid HAVING MAX(date) = date;"], "sol_sql": ["SELECT DISTINCT ON (name) raceid, name, date FROM races ORDER BY name, date DESC;"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'formula_1', conn)    \n    sol_sqls_result = execute_queries(sol_sqls, 'formula_1', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "524_1", "selected_database": "european_football_2", "query": "\nI need to generate a report that lists all possible combinations of match outcomes (win, lose, draw) for each team in the 'european_football_2' database. I tried the following query but it does not work as expected; it only returns a limited set of combinations instead of all possible combinations for each team.\n", "error_sql": ["SELECT t.team_name, o.outcome FROM (VALUES('Team A'),('Team B')) AS t(team_name) JOIN (VALUES('win'),('lose'),('draw')) AS o(outcome);"], "sol_sql": ["SELECT t.team_name, o.outcome FROM (VALUES('Team A'),('Team B')) AS t(team_name) CROSS JOIN (VALUES('win'),('lose'),('draw')) AS o(outcome);"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'european_football_2', conn)    \n    sol_sqls_result = execute_queries(sol_sqls, 'european_football_2', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "522_1", "selected_database": "california_schools", "query": "\nI am working with the california_schools database and need to analyze the frpm table to find the second highest enrollment (K-12) for each County Code, ignoring rows with NULL values in the County Code and Enrollment (K-12) fields. The goal is: Partition the data by County Code. Within each partition, sort the records by Enrollment (K-12) in descending order, with NULL values appearing last. Select the  second highest enrollment record (rn = 2) from each partition. Exclude any counties where there's only one valid record.\n", "error_sql": ["\nSELECT DISTINCT ON (\"County Code\") * FROM frpm ORDER BY \"County Code\", \"Enrollment (K-12)\" DESC;\n"], "sol_sql": ["\nWITH RankedFRPM AS (\n    SELECT *, \n           ROW_NUMBER() OVER (\n               PARTITION BY \"County Code\" \n               ORDER BY \"Enrollment (K-12)\" DESC NULLS LAST\n           ) AS rn \n    FROM frpm\n    WHERE \"County Code\" IS NOT NULL AND \"Enrollment (K-12)\" IS NOT NULL\n) \nSELECT * \nFROM RankedFRPM \nWHERE rn = 2;\n"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'formula_1', conn)    \n    sol_sqls_result = execute_queries(sol_sqls, 'formula_1', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "528_1", "selected_database": "formula_1", "query": "\n", "error_sql": ["SELECT SUM(quantity) FROM race_materials WHERE price_per_unit * quantity <= 100;"], "sol_sql": ["WITH RECURSIVE expanded AS (\n    SELECT \n        name, \n        price_per_unit, \n        ROW_NUMBER() OVER (ORDER BY price_per_unit, name) AS row_number\n    FROM race_materials\n    CROSS JOIN generate_series(1, quantity)\n), \npurchased (name, remaining, next_row_number) AS (\n    SELECT \n        NULL::TEXT AS name, \n        100 AS remaining, \n        1::BIGINT AS next_row_number\n    UNION ALL\n    SELECT \n        expanded.name, \n        purchased.remaining - expanded.price_per_unit, \n        expanded.row_number + 1\n    FROM purchased\n    JOIN expanded \n        ON expanded.row_number = purchased.next_row_number\n    WHERE expanded.price_per_unit <= purchased.remaining\n)\nSELECT COUNT(name) AS qty\nFROM purchased;"], "preprocess_sql": ["CREATE TABLE IF NOT EXISTS race_materials (name text, price_per_unit int, quantity int); INSERT INTO race_materials (name, price_per_unit, quantity) VALUES ('A', 3, 30), ('B', 5, 3), ('C', 5, 3), ('D', 6, 20);"], "clean_up_sql": ["DROP TABLE race_materials;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert int(pred_query_result[0][0]) == 32, f\"Value returned {int(pred_query_result[0][0])} but expected 32\"\n"]}
{"instance_id": "525_1", "selected_database": "formula_1", "query": "\n", "error_sql": ["SELECT \n    drivers.forename, \n    drivers.surname, \n    jsonb_agg(jsonb_strip_nulls(jsonb_build_object('laps', results.laps, 'position', results.position))) AS race_results\nFROM \n    drivers\nJOIN \n    results\nON \n    drivers.driverid = results.driverid\nGROUP BY \n    drivers.forename, \n    drivers.surname\nHAVING \n    jsonb_agg(jsonb_build_object('laps', results.laps, 'position', results.position)) @? '$[*] ? (@.laps == 56) ? (@.position == 1)';"], "sol_sql": ["SELECT d.forename, d.surname, r.race_results\nFROM (\n   SELECT driverid, \n          jsonb_agg(jsonb_build_object('laps', r.laps, 'position', r.position)) AS race_results\n   FROM results r\n   WHERE EXISTS (\n      SELECT 1 \n      FROM results r1\n      WHERE r1.driverid = r.driverid\n      AND   r1.laps = 56\n      AND   r1.position = 1\n   )\n   GROUP BY driverid\n) r\nJOIN drivers d ON d.driverid = r.driverid;"], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(sol_sqls, db_name, conn)       \n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n"], "efficiency": true}
{"instance_id": "523_3", "selected_database": "european_football_2", "query": "\nHow can I generate a table that groups data from a player_attributes table by player_fifa_api_id and player_api_id and, for each group, concatenates the overall_rating values into a field?\n", "error_sql": ["INSERT INTO historical_rating (player_fifa_api_id, player_api_id, grouped_rating) SELECT player_fifa_api_id, player_api_id AS grouped_rating FROM player_attributes GROUP BY player_fifa_api_id, player_api_id;"], "sol_sql": ["INSERT INTO historical_rating (player_fifa_api_id, player_api_id, grouped_rating) SELECT player_fifa_api_id, player_api_id, STRING_AGG(overall_rating::TEXT, ',') AS grouped_rating FROM player_attributes GROUP BY player_fifa_api_id, player_api_id;"], "preprocess_sql": ["CREATE TABLE historical_rating (player_fifa_api_id INT, player_api_id INT, grouped_rating TEXT);"], "clean_up_sql": ["DROP TABLE historical_rating"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT player_api_id FROM historical_rating WHERE player_fifa_api_id = 227760;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == 582500, f'Expected player_api_id to match, but found {test_pred_query_result_1[0][0]}'\n    test_pred_query_result_1 = execute_queries([\"SELECT grouped_rating FROM historical_rating WHERE player_api_id = 306507;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == '64,64,64,64,64,63,63,63,63,64,64,64,62,62', f'Expected grouped_rating to match, but found {test_pred_query_result_1[0][0]}'\n"]}
{"instance_id": "521_4", "selected_database": "codebase_community", "query": "\nIn a database that contains a table named 'posts', each post can reference a parent post through the 'acceptedanswerid' column. The goal is to retrieve posts based on the following conditions: (1) Include the parent post if the parent's 'score' is greater than or equal to 20, and (2) Include the child post if the parent's 'score' is less than 20 but the child's 'score' is greater than or equal to 20. Both parent and child posts should not be included simultaneously if the parent satisfies the condition. How can I write a query to achieve this?\n", "error_sql": ["SELECT DISTINCT id, acceptedanswerid, posttypeid, score FROM posts WHERE score >= 20 OR acceptedanswerid IS NOT NULL AND score >= 20 GROUP BY id, acceptedanswerid;"], "sol_sql": ["SELECT DISTINCT id, acceptedanswerid, posttypeid, score\nFROM (\n  SELECT p.*\n  FROM posts p\n  JOIN posts c ON p.acceptedanswerid = c.id\n  WHERE p.score >= 20\n  UNION ALL\n  SELECT c.*\n  FROM posts p\n  JOIN posts c ON p.acceptedanswerid = c.id\n  WHERE NOT p.score >= 20 AND c.score >= 20\n) x;"], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "527_1", "selected_database": "superhero", "query": "\nIn the superhero database, we want to identify a list of superheroes who have only the superpowers of 'Flight' and 'Telepathy' and do not possess any other superpowers. The following query seems to work, but I suspect there might be a more efficient way to achieve this result.", "error_sql": ["SELECT DISTINCT s.id \nFROM superhero s \nWHERE EXISTS (\n    SELECT 1 \n    FROM hero_power hp \n    JOIN superpower sp ON hp.power_id = sp.id \n    WHERE s.id = hp.hero_id AND sp.power_name = 'Flight'\n) \nAND EXISTS (\n    SELECT 1 \n    FROM hero_power hp \n    JOIN superpower sp ON hp.power_id = sp.id \n    WHERE s.id = hp.hero_id AND sp.power_name = 'Telepathy'\n) \nAND NOT EXISTS (\n    SELECT 1 \n    FROM hero_power hp \n    JOIN superpower sp ON hp.power_id = sp.id \n    WHERE s.id = hp.hero_id AND sp.power_name NOT IN ('Flight', 'Telepathy')\n);"], "sol_sql": ["SELECT DISTINCT s.id \nFROM superhero s \nWHERE s.id IN (\n    SELECT hero_id \n    FROM hero_power \n    WHERE power_id = (\n        SELECT id \n        FROM superpower \n        WHERE power_name = 'Flight'\n    )\n) \nAND s.id IN (\n    SELECT hero_id \n    FROM hero_power \n    WHERE power_id = (\n        SELECT id \n        FROM superpower \n        WHERE power_name = 'Telepathy'\n    )\n) \nAND s.id NOT IN (\n    SELECT hero_id \n    FROM hero_power \n    WHERE power_id NOT IN (\n        (SELECT id FROM superpower WHERE power_name = 'Flight'), \n        (SELECT id FROM superpower WHERE power_name = 'Telepathy')\n    )\n);"], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    result = performance_compare_by_qep(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"performance_check returned {result} but expected 1.\"\n    return result\n"], "efficiency": true}
{"instance_id": "529_3", "selected_database": "card_games", "query": "We have a table with card collection data which includes the start and end dates of when cards were added to and removed from a collection. Not all cards have an end date as they are still in the collection. We need to calculate the number of new cards added per month, cards removed per month, and existing cards per month. We have already completed counts of new and removed cards per month, but we are facing trouble in calculating the existing cards. The data starts from January 2023.", "error_sql": ["WITH card_activity AS ( SELECT to_date(fe.start_date_key::text, 'YYYYMMDD') AS start_date, to_date(fe.end_date_key::text, 'YYYYMMDD') AS end_date, dp.set_name, dp.set_code FROM fact_collection fe INNER JOIN dim_set dp ON fe.set_key = dp.set_key ) SELECT date_trunc('month', month_series) AS month, COUNT(*) AS existing_cards, sa.set_name FROM ( SELECT generate_series( (SELECT MIN(to_date(start_date_key::text, 'YYYYMMDD')) FROM fact_collection), '2100-12-31', INTERVAL '1 month') AS month_series ) AS months LEFT JOIN card_activity sa ON sa.start_date < month_series AND (sa.end_date IS NULL OR sa.end_date >= month_series) GROUP BY month, sa.set_name;"], "sol_sql": ["WITH card_activity AS (\n  SELECT \n    to_date(fe.start_date_key::text, 'YYYYMMDD') AS start_date,\n    to_date(fe.end_date_key::text, 'YYYYMMDD') AS end_date,\n    dp.set_name,\n    dp.set_code,\n    fe.set_key\n  FROM fact_collection fe\n  INNER JOIN dim_set dp ON fe.set_key = dp.set_key\n)\nSELECT \n  date_trunc('month', month_series) AS month,\n  COUNT(DISTINCT fe.card_key) AS existing_cards,\n  sa.set_name\nFROM (\n  SELECT \n    generate_series(\n      (SELECT MIN(to_date(start_date_key::text, 'YYYYMMDD')) FROM fact_collection), \n      '2100-12-31', \n      INTERVAL '1 month'\n    ) AS month_series\n) AS months\nLEFT JOIN card_activity sa ON \n  sa.start_date <= month_series AND \n  (sa.end_date IS NULL OR sa.end_date >= month_series)\nLEFT JOIN fact_collection fe ON \n  fe.set_key = sa.set_key \n  AND fe.start_date_key <= EXTRACT(YEAR FROM month_series) * 10000 + EXTRACT(MONTH FROM month_series) * 100 + 31\n  AND (fe.end_date_key IS NULL OR fe.end_date_key >= EXTRACT(YEAR FROM month_series) * 10000 + EXTRACT(MONTH FROM month_series) * 100 + 1)\nGROUP BY month, sa.set_name\nLIMIT 5;"], "preprocess_sql": ["CREATE TABLE dim_set ( set_key int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL, set_name varchar NULL, set_code varchar NULL ); CREATE TABLE fact_collection ( card_key int4 NULL, start_date_key int4 NULL, end_date_key int4 NULL, set_key int4 NULL ); INSERT INTO dim_set (set_name, set_code) VALUES ('Core Set', '10E'); INSERT INTO fact_collection (card_key, start_date_key, end_date_key, set_key) VALUES (1, 20230105, 20230130, 1), (2, 20230106, 20230120, 1), (3, 20230405, 20230420, 1); INSERT INTO fact_collection (card_key, start_date_key, set_key) VALUES (4, 20230110, 1), (5, 20230120, 1), (6, 20230220, 1), (7, 20230202, 1), (8, 20230228, 1), (9, 20230206, 1), (10, 20230406, 1);"], "clean_up_sql": ["DROP TABLE IF EXISTS fact_collection; DROP TABLE IF EXISTS dim_set;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"instance_id": "576_1", "selected_database": "superhero", "query": "We have a dataset representing time spans during which superheroes have been active in various missions. Each record includes a superhero's ID, the start time, and the end time of their mission. We need to combine multiple rows into a single row where the missions are continuous (i.e., the end time of one mission is the start time of the next mission for the same superhero). The goal is to find the earliest start time and the latest end time for each continuous span of missions for each superhero.", "error_sql": ["WITH mission_spans AS ( SELECT hero_id, mission_start, mission_end FROM superhero_missions ORDER BY hero_id, mission_start, mission_end ) SELECT hero_id, MIN(mission_start) OVER (PARTITION BY hero_id), MAX(mission_end) OVER (PARTITION BY hero_id) FROM mission_spans ORDER BY 1, 2, 3"], "sol_sql": ["WITH data AS (  SELECT hero_id, mission_start, mission_end FROM superhero_missions ORDER BY hero_id, mission_start ), mark_gaps AS ( SELECT hero_id, mission_start, mission_end,  COALESCE(LAG(mission_end) OVER w < mission_start, true) AS is_end_grp FROM data WINDOW w AS (PARTITION BY hero_id ORDER BY mission_start) ), numbered_groups AS ( SELECT hero_id, SUM(is_end_grp::int) OVER (PARTITION BY hero_id  ORDER BY mission_start) AS grp_num, mission_start, mission_end FROM mark_gaps ) SELECT hero_id, MIN(mission_start) AS v_start, MAX(mission_end) AS v_stop FROM numbered_groups GROUP BY hero_id, grp_num  ORDER BY hero_id, v_start; "], "preprocess_sql": ["CREATE TABLE superhero_missions ( hero_id bigint, mission_start timestamp, mission_end timestamp );", "INSERT INTO superhero_missions (hero_id, mission_start, mission_end) VALUES (1, '2023-01-01 09:00:00', '2023-01-01 10:00:00'), (1, '2023-01-01 10:00:00', '2023-01-01 11:00:00'), (1, '2023-01-01 11:00:00', '2023-01-01 12:00:00'), (1, '2023-01-01 13:00:00', '2023-01-01 14:00:00'), (1, '2023-01-01 14:00:00', '2023-01-01 15:00:00'), (1, '2023-01-01 15:00:00', '2023-01-01 16:00:00'), (2, '2023-01-01 10:00:00', '2023-01-01 11:00:00'), (2, '2023-01-01 11:00:00', '2023-01-01 12:00:00'), (2, '2023-01-01 13:00:00', '2023-01-01 14:00:00'), (3, '2023-01-01 10:00:00', '2023-01-01 11:00:00');"], "clean_up_sql": ["DROP TABLE IF EXISTS superhero_missions;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"instance_id": "577_1", "selected_database": "card_games", "query": "I am trying to find the median release date of all card sets in the 'sets' table of the card_games database. The goal is to obtain the date that is in the middle of all the release dates. I attempted to use the percentile_cont function directly on the date column, but encountered an error. Here is the SQL statement I used:", "error_sql": ["SELECT percentile_cont(0.5) within group (ORDER by releasedate) FROM sets"], "sol_sql": ["SELECT to_timestamp(percentile_cont(0.5) within group (ORDER by cast (extract(epoch from releasedate) as integer)))::date FROM sets"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"instance_id": "578_1", "selected_database": "formula_1", "query": "I am creating a table to track race incidents and I need a check constraint to validate the possible values given a string value. I am creating this table: \\\\", "error_sql": ["CREATE TABLE race_incidents ( incident_type VARCHAR(30) NOT NULL CHECK(incident_type = 'Engine failure' OR incident_type = 'Collision'), incident_description VARCHAR(30) NOT NULL);"], "sol_sql": ["CREATE TABLE race_incidents ( incident_type VARCHAR(30) NOT NULL, incident_description VARCHAR(30) NOT NULL CHECK(CASE incident_type WHEN 'Engine failure' THEN incident_description IN ('Piston failure', 'Cylinder head gasket') WHEN 'Collision' THEN incident_description IN ('High-speed impact', 'Low-speed impact') END));"], "preprocess_sql": [], "clean_up_sql": [], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Engine failure', 'Piston failure');\"], db_name, conn)[0];\n    assert test_pred_query_result_1 == None, f'Expected 0 rows, but found {test_pred_query_result_1}'\n    test_pred_query_result_2 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Collision', 'High-speed impact');\"], db_name, conn)[0];\n    assert test_pred_query_result_2 == None, f'Expected 0 rows, but found {test_pred_query_result_2}'\n    test_pred_query_result_3 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Engine failure', 'Cylinder head gasket');\"], db_name, conn)[0];\n    assert test_pred_query_result_3 == None, f'Expected 0 rows, but found {test_pred_query_result_3} rows'\n    test_pred_query_result_4 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Collision', 'Low-speed impact');\"], db_name, conn)[0];\n    assert test_pred_query_result_4 == None, f'Expected 0 rows, but found {test_pred_query_result_4}'\n    test_pred_query_result_5 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Collision', 'Piston failure');\"], db_name, conn)[1];\n    assert test_pred_query_result_5 == True, f'There should be constraint viloation error.'\n"]}
{"instance_id": "579_1", "selected_database": "superhero", "query": "I am trying to create a SQL query to update a column in my superhero table to reflect the total number of powers each superhero has. The superhero table currently has a column 'total_powers' which is NULL for all entries. The hero_power table contains the mapping of heroes to their powers. The result set should look like this:\\nsuperhero table:\\n|ID  |  superhero_name|  total_powers|\\n-----|-----------------|--------------|\\n|1   |  3-D Man        |  2           |\\n|2   |  A-Bomb         |  1           |\\n|3   |  Abe Sapien     |  1           |\\n|4   |  Superman       |  0           |\\nWhen there are no power rows for a superhero, the result should return 0.\\nI tried using:\\n\\nUPDATE superhero \\\\\\\\nSET total_powers = (SELECT COUNT(power_id) FROM hero_power);\\n\\nI don't know how to use GROUP BY to calculate for distinct count. The result works to show the count for all powers not by superhero.\\", "error_sql": ["UPDATE superhero SET total_powers = (SELECT COUNT(power_id) FROM hero_power);"], "sol_sql": ["UPDATE superhero SET total_powers = (SELECT COUNT(power_id) FROM hero_power WHERE hero_id = superhero.id)"], "preprocess_sql": ["ALTER TABLE superhero ADD COLUMN total_powers INT DEFAULT NULL;"], "clean_up_sql": ["ALTER TABLE superhero DROP COLUMN total_powers;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries(pred_sqls, db_name, conn)\n    pred_sqls_result = execute_queries([\"SELECT total_powers FROM superhero ORDER BY id;\"], db_name, conn)\n    execute_queries(sol_sqls, db_name, conn)\n    sol_sqls_result = execute_queries([\"SELECT total_powers FROM superhero ORDER BY id;\"], db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\""]}
{"instance_id": "267_1", "selected_database": "financial", "query": "In the financial database, we have two tables: `trans` and `account`. The `trans` table tracks all transactions made on each account, with multiple rows per account. The `account` table contains only one row per account, representing the most recent transaction details. We need to update the `account` table with the details of the most recent transaction (highest `trans_id`) for each account. The tables have many columns, so we would like to use a method that includes all fields in the update without explicitly listing them.", "error_sql": ["select * from trans t1 where (account_id, trans_id) in (select account_id, max(trans_id) from trans t1 group by account_id);"], "sol_sql": ["UPDATE latest_trans a SET (amount, trans_id) = (SELECT amount, trans_id FROM trans t WHERE t.account_id = a.account_id ORDER BY t.trans_id DESC LIMIT 1);"], "preprocess_sql": ["CREATE TABLE latest_trans AS SELECT DISTINCT account_id, 0 AS amount, 0 AS trans_id FROM trans;"], "clean_up_sql": ["drop table if exists latest_trans;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"select max(trans_id) from trans where account_id = 1;\"], db_name, conn)[0]\n    test_pred_query_result_2 = execute_queries([\"select max(trans_id) from latest_trans where account_id = 1;\"], db_name, conn)[0]\n    assert test_pred_query_result_2 == test_pred_query_result_1, f\"Expected equal but got {test_pred_query_result_1} {test_pred_query_result_2}\"\n\n    test_pred_query_result_3 = execute_queries([\"select max(trans_id) from trans where account_id = 107;\"], db_name, conn)[0]\n    test_pred_query_result_4 = execute_queries([\"select max(trans_id) from latest_trans where account_id = 107;\"], db_name, conn)[0]\n    assert test_pred_query_result_3 == test_pred_query_result_4, f\"Expected equal but got {test_pred_query_result_3} {test_pred_query_result_4}\"\n\n    test_pred_query_result_5 = execute_queries(['SELECT COUNT(*) FROM latest_trans;'], db_name,conn)[0]\n    assert test_pred_query_result_5[0][0] == 4500, 'The total number of records in the attendance table should remain unchanged after the update.'\n"]}
{"instance_id": "255_2", "selected_database": "european_football_2", "query": "I am trying to run a recursive query in PostgreSQL to find all teams that belong under a specific league. The query is the following: I need to find all teams that are part of a league and any sub-leagues they might belong to. However, I am encountering issues with the recursive CTE. The error seems to be related to the structure of the CTE and the use of UNION instead of UNION ALL. Additionally, I am unsure how to properly reference the initial CTE within the recursive part of the query.", "error_sql": ["WITH TAB AS (SELECT id as league_id, name FROM League UNION SELECT id, name FROM League) , RECURSIVE recuree AS ( SELECT league_id, name FROM TAB UNION SELECT E.league_id, E.name FROM TAB E JOIN recuree S ON E.id = S.league_id)  SELECT * FROM recuree"], "sol_sql": ["WITH RECURSIVE recuree AS (SELECT id AS league_id, name FROM League UNION ALL SELECT L.id AS league_id, L.name FROM League L JOIN recuree R ON L.id = R.league_id) SELECT * FROM recuree LIMIT 50;"], "preprocess_sql": [""], "clean_up_sql": [""], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
